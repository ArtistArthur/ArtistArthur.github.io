<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cpp-链接</title>
    <url>/2022/02/04/cpp-lian-jie/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>malloc原理</title>
    <url>/2021/02/16/linux-malloc-yuan-li/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_41562665/article/details/90546750" target="_blank" rel="noopener">https://blog.csdn.net/qq_41562665/article/details/90546750</a> 实现一个高并发内存池—–对比Malloc<br><a href="https://blog.csdn.net/qq_34488711/article/details/77367259" target="_blank" rel="noopener">https://blog.csdn.net/qq_34488711/article/details/77367259</a><br><a href="https://blog.csdn.net/u012489236/article/details/112158568?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/u012489236/article/details/112158568?utm_medium=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task-blog-baidujs-1.nonecase</a>  linux内存管理笔记(三十四）—-匿名映射<br><a href="https://blog.csdn.net/qq_22238021/article/details/80052234" target="_blank" rel="noopener">https://blog.csdn.net/qq_22238021/article/details/80052234</a> 内存分配策略和分配方法<br><a href="https://blog.csdn.net/luckyxiaoqiang/article/details/8669602" target="_blank" rel="noopener">https://blog.csdn.net/luckyxiaoqiang/article/details/8669602</a> 动态内存分配（malloc/free）简单实现–隐式空闲链表<br><a href="https://blog.csdn.net/weixin_39933082/article/details/111271365" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39933082/article/details/111271365</a> 显式空闲链表和隐式空闲链表_Innodb Buffer Pool的三种Page和链表<br><a href="https://blog.csdn.net/qqliyunpeng/article/details/91407705" target="_blank" rel="noopener">https://blog.csdn.net/qqliyunpeng/article/details/91407705</a>  malloc原理学习：隐式空闲链表</p>
<p>以前不理解<code>malloc()</code>实际上是被两样不同的东西迷惑了:用户层面的内存分配和内核层面的内存分配.在看资料的时候两个方面的内容交叉看,导致了混乱.<br>以下内容取自csapp(深入理解计算机系统)第十章第九节.最好去看这本书的内容,网上的许多讲解都是copy这本书上的内容但是又漏了或者错了一些地方.下面是我读了之后对<code>malloc()</code>的理解.  </p>
<a id="more"></a>
<h1 id="用户层面的堆上内存分配"><a href="#用户层面的堆上内存分配" class="headerlink" title="用户层面的堆上内存分配"></a>用户层面的堆上内存分配</h1><p><code>malloc()</code>层面,或者说成编译器层面,本身维护一个内存池.一开始时,用户已经拥有了一定大小的堆,当申请的内存大小能在这个内存池中被满足时,就从这个内存池里分配出去.<br>此时的内存分配策略有:</p>
<ul>
<li>首次适应(first fit):空闲块按照地址递增的次序链接在一起,每次分配从头依次遍历,选择第一个满足要求的块</li>
<li>循环首次适应(next fit):空闲块按照地址递增的次序链接在一起,从上次分配后的位置遍历,选择第一个满足要求的块</li>
<li>最佳适应(best fit):空闲块按照空闲大小递增的次序链接在一起,每次分配从头依次遍历,选择第一个满足要求的块</li>
<li>最坏适应(worst fit):空闲块按照空闲大小递减的次序链接在一起,每次分配从头依次遍历,选择第一个满足要求的块  </li>
</ul>
<p>查找速度、释放速度、空闲区利用这三个方面:</p>
<ul>
<li>查找(搜索)速度:最先适应算法最佳</li>
<li>释放(回收)速度:最先适应算法最佳</li>
<li>空闲区利用:最佳适应算法最佳  </li>
</ul>
<p>从搜索速度上看最先适应算法拥有最佳性能,回收过程最先适应算法也是最佳,最先适应算法的另一个优点是尽可能的利用了低地址空间从而保证高地址有较大的空闲区来放置要求内存较多的进程或作业。<br>最坏适应算法是基于不留下碎片空闲区出发,选择最大空闲区满足用户需求,按如上方法分配后的剩余部分仍能再分配。   </p>
<p>内存池的组织方式:   </p>
<ul>
<li>隐式链表</li>
<li>显式链表  </li>
</ul>
<h2 id="隐式链表"><a href="#隐式链表" class="headerlink" title="隐式链表"></a>隐式链表</h2><p>任何实际的分配器都需要一些数据结构来区分块边界,类似于元数据,并区分已分配块和空闲块.大多数分配器将这些信息嵌在块本身中,一个简单的方法是:<br><img src="/images/loading.gif" data-original="https://i.bmp.ovh/imgs/2021/02/0818d9e7bafc9957.png" alt="一个简单的堆块格式"><br>在这个格式中,低的三位作为属性位,最低位作为属性中的已分配/空闲标志.<br>每个块的大小一定是8字节对齐的(或者按照系统要求可以是其他大小对齐),即8的倍数,因此大小低三位一定是0,因此低三位可以作为属性位.<br>这种结构之所以叫做隐式链表,是因为块是通过头部中的大小字段隐含地连接在一起的.下一个块的位置可以根据当前块的地址,加上当前块的大小得到,而没有额外通过<code>next</code>指针指向下一个节点.这种方式要求:块与块一定是紧邻的,也就是需要连续的一片内存.<br>另外,这种结构也要求有最小块大小,即如果只申请一个字节的内存,而系统要求8字节对齐,头部是4字节那么实际上需要耗费8字节:4字节头部,1字节有效载荷,3字节填充.因此对于大量小块分配不友好,内存利用率不高.<br>隐式空闲链表的优点是简单,显著缺点是任何操作的开销,比如放置分配的块(找到将要分配的内存的位置),其搜索合适的空闲块的开销与总的块数量(已分配块的数量+空闲块的数量)呈线性关系(因为最坏情况需要遍历完所有块,从头遍历到尾,如果只有两个大的空闲块和两个已分配块,则只需要遍历4次,而如果总共有100个块,则需要遍历100次).<br>值得一提的是,<code>mit6.828</code>课程实验中的lab2实现的简单内存管理,不把内存的元数据储存在空闲内存本身,而是额外分配一个数组,数组中每个元素对应了一个页(4k)的内存块,以此来粗粒度管理内存.而这个数组本身所在的页s始终被标记为已分配.  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Page descriptor structures, mapped at UPAGES.</span></span><br><span class="line"><span class="comment"> * Read/write to the kernel, read-only to user programs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Each struct PageInfo stores metadata for one physical page.</span></span><br><span class="line"><span class="comment"> * Is it NOT the physical page itself, but there is a one-to-one</span></span><br><span class="line"><span class="comment"> * correspondence between physical pages and struct PageInfo's.</span></span><br><span class="line"><span class="comment"> * You can map a struct PageInfo * to the corresponding physical address</span></span><br><span class="line"><span class="comment"> * with page2pa() in kern/pmap.h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> {</span></span><br><span class="line">	<span class="comment">// Next page on the free list.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line">	<span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line">	<span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line">	<span class="comment">// Pages allocated at boot time using pmap.c's</span></span><br><span class="line">	<span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line">	<span class="keyword">uint16_t</span> pp_ref;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>每次<code>malloc()</code>会返回头部之后的有效载荷的指针,如果有对齐要求,会在有效载荷后填充几个字节,即多分配几个字节,使得下个块的起始地址满足对齐条件.在大多数情况下对齐是要求4/8/16字节,因此这个头部的块大小不会影响对齐.需要注意的是,这个对齐是对于真正返回的指针而言的,也就是说,块的头部地址并不对齐,而是有效载荷的首地址需要对齐.<br><code>free()</code>函数可以根据这个头部信息来释放相应的内存.(这就是为什么<code>free()</code>可以知道你申请了多大的内存).这个时候如果你强行访问<code>malloc()</code>返回指针的前面几个字节的内容或后面填充字节的内容,编译器不会报错,操作系统也不会报错,因为它不会产生一般保护性异常(因为没有相关设施来检测这个异常,mmu可以检测页权限但是检测不到这个),但是运行过程中会出现意想不到的错误.<br>重复<code>free()</code>同一个内存出问题的原因也是这个,如果<code>free()</code>之后,这块内存没被改动,那么再<code>free()</code>之后,<code>free()</code>发现这个内存已经是空闲的了,要么它可以报错,要么当无事发生,这要看具体实现;如果第一次<code>free()</code>之后,这块内存被合并了,那么再次<code>free()</code>的时候会发现找不到这个头了,或者头里面内容有问题,这个时候也可以报错或者当作无事发生,也要看具体实现;如果第一次<code>free()</code>之后,这块内存被使用了,那么如果再去<code>free()</code>,如果<code>free()</code>发现有问题,要么报错,要么正常修改,但是修改后有可能发生意想不到的错误,这也要看具体实现了.<br>但是基本上重复<code>free()</code>的风险比内存泄漏大得多,所以基本是所有的实现都会把重复free的程序给终止掉.  </p>
<h3 id="放置分配的块"><a href="#放置分配的块" class="headerlink" title="放置分配的块"></a>放置分配的块</h3><p>当一个应用请求一个<code>k</code>字节的块时,分配器搜索空闲链表,查找一个足够大的,可以放置所请求的块的空闲块.分配器执行这种搜索的方式是由放置策略确定的.这些策略有首次适配,循环首次适配,最佳适配等.<br>对于隐式链表来说,最佳适配要求搜索完全部块再确定被选中的块,而某些分离式空闲链表组织,把空闲块按照块大小递增的顺序连接,则不需要彻底搜索空闲块,它的首次适配即为最佳适配.但释放和合并的开销更大.  </p>
<h3 id="分割空闲块"><a href="#分割空闲块" class="headerlink" title="分割空闲块"></a>分割空闲块</h3><p>当分配器找到匹配的空闲块之后,需要做另一个策略决定,那就是分配这个空闲空间中的多少空间.<br>一个选择是用整个空闲块,这十分快捷但是内碎片会更多,利用率更低.<br>另一个选择是把这个空闲块分割为两个部分,第一部分变为分配块,剩下的部分变成新的空闲块.</p>
<h3 id="获取额外的堆内存"><a href="#获取额外的堆内存" class="headerlink" title="获取额外的堆内存"></a>获取额外的堆内存</h3><p>如果分配器在当前内存池中无法找到合适的空闲块,那么有两种选择.  </p>
<ul>
<li>第一个选择是通过合并那些相邻的空闲块来生成一些更大的空闲块.</li>
<li>如果第一个选择不行,那么分配器将向内核请求额外的堆内存,要么通过<code>mmap()</code>函数,要么通过<code>sbrk()</code>函数.然后把得到的内存转换为一个足够大的空闲块,并把它插入链表中.</li>
</ul>
<h3 id="合并空闲块"><a href="#合并空闲块" class="headerlink" title="合并空闲块"></a>合并空闲块</h3><p>当分配器释放一个已分配块时,有可能有其他空闲块与这个新释放的空闲块相邻.此时可以合并这些相邻的空闲块.<br>一个重要的策略抉择是何时合并这些空闲块.  </p>
<ul>
<li>立即合并:在每次释放一个块时就合并所有相邻的块.</li>
<li>推迟合并:等到某个稍晚的时候再合并空闲块,例如当某次分配请求失败时(即找不到足够大的空闲块时).</li>
</ul>
<p>立即合并可以在常数时间内执行完成,因为一般不会产生连锁反应,只需要检查前一个块和后一个块就可以了,最多合并这三个块.但是在某些情况下,立即合并会产生一种形式的抖动:块会反复地合并,然后马上分割(比如先释放k字节的块,然后这个块后面有空闲的块,会产生合并,然后马上又申请k字节的块,很可能会又重新分配同一个位置,又要分割,如果这个释放分配交替反复,则会不必要的分割和合并,从而出现抖动).<br>现实中,快速的分配器通常会选择某种形式的推迟合并.  </p>
<h3 id="带边界标记的合并"><a href="#带边界标记的合并" class="headerlink" title="带边界标记的合并"></a>带边界标记的合并</h3><p>在合并中有一个问题,如何知道前一个块的状态是空闲还是以分配,因为隐式链表相当于只有<code>next</code>指针没有<code>last</code>指针,因此如果想知道前一个块的状态就需要遍历整个隐式链表.<br>为了解决这个问题<code>Knuth</code>提出了一种聪明而通用的技术叫<strong>边界标记</strong>,以运行在常数的时间内对前一个块进行合并.<br>边界标记通过在每一个块的结尾添加一个头部的副本,称为脚部,来让下一个块得知自己的状态和起始位置(当前块脚部与下一个块的头部相连,下一个块通过指针运算就可以访问当前块的脚部了).<br><img src="/images/loading.gif" data-original="https://i.bmp.ovh/imgs/2021/02/f2aa34ca64ec9da5.png" alt="使用边界标记的堆块格式"><br>但是通过增加脚部很明显降低了内存使用率,增大了块的最小大小.<br>巧妙的是,有一种非常聪明的边界标记的优化方法,可以使得已分配块中不再需要脚部:</p>
<ul>
<li>把前一个块的已分配/空闲状态储存在下一个块的头部多出来的低位中.</li>
</ul>
<p>采用这种方式的启发想法是:只有前面的块是空闲的时候,才会需要他的脚部信息.因此可以只在空闲的块中设置脚部,而已分配的不需要设置.<br>通过这种方式,使得已分配的块不需要脚部,而空闲块中仍有脚部,但空闲块本来也是空闲的,不用白不用,对内存利用率没有影响.<br>即,当要合并当前块时,通过查看当前块的头部信息,判断前一个块是否空闲:</p>
<ul>
<li>如果不空闲,则不用合并,也不需要前一个块的大小/地址信息,即脚部.</li>
<li>如果空闲,则前一个块会有脚部,也就可以得到前一个快的起始地址.  </li>
</ul>
<h1 id="内核层面的堆内存分配"><a href="#内核层面的堆内存分配" class="headerlink" title="内核层面的堆内存分配"></a>内核层面的堆内存分配</h1><p>当通过<code>malloc()</code>申请的内存大小不能在<code>malloc()</code>维护的内存池中找到时,需要向内核申请新的内存映射以获得内存(写时拷贝/分配).此时需要通过系统调用<code>brk()</code>或者<code>sbrk()</code>.当内核收到这两个系统调用的时候,在内核的内存池中寻找满足条件的内存块,通过页表映射到用户的虚拟地址空间中.(分配时机?)<br>内核的内存池分配策略也和上面相同.<br>伙伴系统.slab?</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Linux-中断</title>
    <url>/2022/02/04/linux-zhong-duan/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/zhangskd/article/details/21992933" target="_blank" rel="noopener">https://blog.csdn.net/zhangskd/article/details/21992933</a> 硬中断和软中断</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Linux-信号</title>
    <url>/2022/02/04/linux-xin-hao/</url>
    <content><![CDATA[<p>信号是进程间通信的一种方式，它由一个进程或者内核产生，然后传递给另一个进程，作用是告诉目标进程发生了一个特定的事件，有时会强迫目标进程执行它自己代码中的信号处理程序。<br>通常一个信号是单独的一个数，以SIG开头的宏表示。<br>内核把信号分为两个阶段，一个是信号的产生，在这个阶段内核更新目标进程中的数据结构，比如信号描述符，来表示一个信号已经产生<br>。<br>另一个阶段是信号的传递，如果目标进程没有处于运行状态，信号的传递将会被延迟，直到目标进程从中断或者异常中恢复之前，内核检查进程的相关信号标志，看是否有信号等待处理，有的话就处理它，然后才能恢复进程的正常执行。  </p>
<a id="more"></a>

<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>信号在最早的Unix系统中被引入，用于在用户态进程间通信，内核也用信号通知进程系统所发生的事件，信号有30多年的历史，但只有很小的变化。  </p>
<h2 id="信号的作用"><a href="#信号的作用" class="headerlink" title="信号的作用"></a>信号的作用</h2><p>信号是很短的消息，可以被发送到一个或者一组进程。发送给进程的唯一信号通常是一个数，以此来标识信号。<br>名字前缀为SIG的一组宏用来标识信号。<br>比如SIGCHLD宏（扩展值是17），当某一子进程停止或者中止时，SIGCHLD宏产生发送给父进程的信号标识符。<br>SIGSEGV宏扩展值是11，当一个进程引用无效的内存时，SIGSEGV宏产生发送给进程的信号标识符。<br>信号的两个主要目的是：  </p>
<ul>
<li>让进程知道以及发生了一个特定的事件  </li>
<li>强迫进程执行它自己代码中的信号处理程序  </li>
</ul>
<p>这两个目的不是互斥的，可以同时发生，因为进程经常通过一个特定的例程来对某一事件做出反应。<br>Linux处理的0-31号信号叫做常规信号，后来POSIX标准又增加了32个信号，扩展值为32-64，叫做实时信号，他们与常规信号有很大的不同：  </p>
<ul>
<li>实时信号必须排队，以便发送的多个信号能被接收到</li>
<li>同种类型的常规信号并不排队，如果一个常规信号被连续发送多次，那么只有其中的一个发送到接收进程。  </li>
</ul>
<p>许多系统调用运行程序员发送信号并决定他们的进程如何响应所接收的信号。<br><code>kill()</code>向线程组发送一个信号。<br>信号的一个重要特点是它可以随时被发送给状态经常不可预知的进程，发送给非运行进程的信号必须由内核保存，直到进程恢复执行。<br>内核区分信号传递的两个同阶段：  </p>
<ul>
<li>信号产生：内核更新目标进程的数据结构以表示一个新信号已经被发送</li>
<li>信号传递： 内核强迫目标进程通过以下方式对信号做出反应：或改变目标进程的执行状态，或开始执行一个特定的信号处理程序，或者两个都是。  </li>
</ul>
<p>每个信号最多被传递一次，它是可消耗资源，一旦它们已经被传递出去，进程描述符中有关这个信号的 所有消息都被取消。<br>xxxxxxxxxxxx<br>xxxxxxxx  </p>
<h2 id="信号的相应结构"><a href="#信号的相应结构" class="headerlink" title="信号的相应结构"></a>信号的相应结构</h2><p>信号在进程描述符中有相应的结构：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* signal handlers */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> blocked, real_blocked;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line">    <span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line">    <span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);</span><br><span class="line">    <span class="keyword">void</span> *notifier_data;</span><br><span class="line">    <span class="keyword">sigset_t</span> *notifier_mask;</span><br></pre></td></tr></tbody></table></figure>
<p><code>signal</code>是一个指针，指向进程的信号描述符。</p>
<h2 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h2><p>很多内核函数都会产生信号：他们完成信号处理的第一步工作，根据需要更新一个或多个进程的描述符。它们不直接执行第二步信号的传递操作，而是可能根据信号类型和目标进程的状态唤醒一些进程 ，并促使这些进程接收信号。<br>当发送给进程一个信号时，这个信号可能来自内核，也可能来自另一个进程。  </p>
<h2 id="传递信号"><a href="#传递信号" class="headerlink" title="传递信号"></a>传递信号</h2><p>我们假定内核已经注意到一个信号的到来，并调用前面所介绍的函数为接收此信号的进程准备信号描述符。但万一这个进程在那一刻并不在cpu上运行，内核就延迟传递信号的任务。而为了确保进程的挂起信号得到处理，内核有一些特殊的操作。<br>内核在允许进程恢复用户态下的执行之前，检查进程<code>TIF_SIGPENDING</code>标志的值，每当内核处理完一个中断或异常时，就检查是否存在挂起信号。<br>为了处理非阻塞的挂起信号，内核调用<code>do_signal()</code>这个函数它接收两个参数：</p>
<ul>
<li>regs：栈区的地址，当前进程在用户态下寄存器的内容放在这个栈中。</li>
<li>oldset：变量的地址，假设函数把阻塞信号的位掩码数组存放在这个变量中。如果没有必要保存位掩码数组，则它为NULL。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Linux-内核内存分布</title>
    <url>/2022/02/04/linux-nei-he-nei-cun-fen-bu/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_38410730/article/details/81105132" target="_blank" rel="noopener">【Linux】Linux的内核空间（低端内存、高端内存</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>分页</title>
    <url>/2020/10/31/linux-fen-ye/</url>
    <content><![CDATA[<h2 id="分页机制的具体细节"><a href="#分页机制的具体细节" class="headerlink" title="分页机制的具体细节"></a>分页机制的具体细节</h2><ul>
<li>页目录：存放页表地址的一个目录（或者说是一个表）</li>
<li>页表:存放具体的页帧的地址的一个表<br><img src="/images/loading.gif" data-original="https://ftp.bmp.ovh/imgs/2020/10/226caa5bbf53d9bd.png" alt="线性地址和物理地址之间的变换"></li>
<li>页目录和页表里面的内容都是一样的：共32位，高20位是页帧的物理地址，后12位是一些标志位（比如存在为P），实际上他们无区别，只是解释不同<br><img src="/images/loading.gif" data-original="https://ftp.bmp.ovh/imgs/2020/10/00b5e0e8aed71b34.png" alt="页目录页表项"></li>
<li>实际上一个页目录本身也是一个页面（帧）大小是4K，一个页目录项占4B，因此一个页目录可以放1024个目录项</li>
<li>同理，一个页表本身也是一个页面（帧），大小是4K，一个页表项占4B，因此一个页表可以存1024个页帧地址。<a id="more"></a></li>
<li>CR3的结构：<br><img src="/images/loading.gif" data-original="https://ftp.bmp.ovh/imgs/2020/10/9789493f86f1c729.png" alt="CR3的结构"><h2 id="线性地址到物理地址的转换过程"><a href="#线性地址到物理地址的转换过程" class="headerlink" title="线性地址到物理地址的转换过程"></a>线性地址到物理地址的转换过程</h2></li>
<li>首先从CR3寄存器取得页目录基地址，从而找到页目录物理地址</li>
<li>取线性地址的高10位为索引号，从页目录中找到对应的页目录项，从而找到页表的物理地址（为什么是十位：因为4K页面内可以存1024个页目录项）</li>
<li>取线性地址的接下来10位，作为索引号，从页表中找到对应页表项，里面有页面的物理地址（10位理由同上）</li>
<li>然后取线性地址的低12位，作为页内偏移值，精确找到某一Byte。</li>
<li>这个寻址过程是硬件完成的（mmu）而不是软件，因为软件不可以接触物理地址<h2 id="64为系统的分页细节"><a href="#64为系统的分页细节" class="headerlink" title="64为系统的分页细节"></a>64为系统的分页细节</h2></li>
<li>64位系统使用48位地址，256TB内存</li>
<li>多级分页：<ul>
<li>首先一个页面大小还是4K，但是一个页面地址需要64储存，即8B，所以一个页面只能存$2^9$个页面的地址</li>
<li>因此线性地址要分成$9 9 9 9 12$的结构有四级目录</li>
<li>目录分级是为了节省空间，分级之后，没有用到的内存就不需要页表项存在，就不需要内存存它，而如果不分级，总共要分成2^36个页面，共需要2^36 x 8B的内存=512GB的内存存页面地址  </li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令</title>
    <url>/2020/09/21/linux-ming-ling/</url>
    <content><![CDATA[<h1 id="Linux命令练习"><a href="#Linux命令练习" class="headerlink" title="Linux命令练习"></a>Linux命令练习</h1><p>shell不仅仅是用户命令解释器，同时一种强大的编程语言，Linux缺省的shell是bash<br><code>$$</code>Shell本身的PID（ProcessID）<br><code>$!</code>Shell最后运行的后台Process的PID<br><code>$?</code>最后运行的命令的结束代码（返回值）<br><code>$#</code>添加到Shell的参数个数<br><code>$0</code>Shell本身的文件名<br><code>$1～$n</code>添加到Shell的各参数值。$1是第1参数、$2是第2参数…。<br><code>du</code>disk usage 显示当前目录下文件和目录的大小  </p>
<h2 id="用到的Linux常用命令及解释"><a href="#用到的Linux常用命令及解释" class="headerlink" title="用到的Linux常用命令及解释"></a>用到的Linux常用命令及解释</h2><p>uname : 英文全拼 unix name  用于显示系统信息 可显示电脑以及操作系统的相关信息<br>-a 或 –a 显示全部的信息<br>-m 或 –machine 显示电脑类型<br>-n 或 –nodename 显示在网络上的主机名称<br>-r 或 –release 显示操作系统的发行编号<br>-s 或 –sysname 显示操作系统名称<br>-v 显示操作系统的版本</p>
<a id="more"></a>
<p>apt : advanced package tool<br>apt-get  xxx  install  </p>
<p>cp :英文全拼 copy file 用于复制文件或目录<br>cp [options] source dest  </p>
<p>pwd:print working dictory 显示当前目录的路径  </p>
<p>~:用户根目录</p>
<p>#是管理员 $是用户<br>了解了<br>yum : yellow dogUpdater， Modified<br>sudo : superuser do<br>rm -rf: rm remove -r delete files recrusively -f force  delete without warning<br><code>ps -ef | grep tomcat</code>ps命令用于报告当前系统进程状态,-e参数表示显示所有用户所有进程,-f参数表示全格式显示<br>grep全称是Globally search a Regular Expression and Print,能使用特定模式匹配(包括正则表达式)搜索文本,并默认输出匹配行,所以用管道连接后,这个命令就表示显示所有进程,并且格式化输出,然后用“tomcat”字符串来过滤每一行,得到最终的输出结果  </p>
<h2 id="vim语法"><a href="#vim语法" class="headerlink" title="vim语法"></a>vim语法</h2><p>1.在命令模式下输入v进入自由选取模式,选择需要剪切的文字，按下d可以剪切.<br>2.其他命令模式下剪切命令:   </p>
<figure class="highlight avrasm"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">dd:</span>剪切当前行    </span><br><span class="line"><span class="symbol">ndd:</span>n表示大于<span class="number">1</span>的数字，剪切n行  </span><br><span class="line"><span class="symbol">dw:</span>从光标处剪切至一个单词的末尾，包括空格  </span><br><span class="line"><span class="symbol">de:</span>从光标处剪切至一个单词的末尾，不包括空格  </span><br><span class="line"><span class="symbol">d$:</span>从当前光标剪切到行末  </span><br><span class="line"><span class="symbol">d0:</span>从当前光标位置（不包括光标位置）剪切之行首  </span><br><span class="line"><span class="symbol">d3l:</span>从光标位置（包括光标位置）向右剪切<span class="number">3</span>个字符  </span><br><span class="line"><span class="symbol">d5G:</span>将当前行（包括当前行）至第<span class="number">5</span>行（不包括它）剪切  </span><br><span class="line"><span class="symbol">d3B:</span>从当前光标位置（不包括光标位置）反向剪切<span class="number">3</span>个单词  </span><br><span class="line"><span class="symbol">dH:</span>剪切从当前行至所显示屏幕顶行的全部行  </span><br><span class="line"><span class="symbol">dM:</span>剪切从当前行至命令M所指定行的全部行  </span><br><span class="line"><span class="symbol">dL:</span>剪切从当前行至所显示屏幕底的全部行</span><br></pre></td></tr></tbody></table></figure>
<p>3.复制</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">yy：复制当前行</span><br><span class="line">nyy：n表示大于<span class="number">1</span>的数字，复制n行</span><br><span class="line">yw：从光标处复制至一个单词的末尾，包括空格</span><br><span class="line">ye：从光标处复制至一个单词的末尾，不包括空格</span><br><span class="line">y$：从当前光标复制到行末</span><br><span class="line">y0：从当前光标位置（不包括光标位置）复制之行首</span><br><span class="line">y3l：从光标位置（包括光标位置）向右复制<span class="number">3</span>个字符</span><br><span class="line">y5G：将当前行（包括当前行）至第<span class="number">5</span>行（不包括它）复制</span><br><span class="line">y3B：从当前光标位置（不包括光标位置）反向复制<span class="number">3</span>个单词</span><br></pre></td></tr></tbody></table></figure>

<h2 id="杂乱的知识"><a href="#杂乱的知识" class="headerlink" title="杂乱的知识"></a>杂乱的知识</h2><p>大端:数据低字节在内存高位 可以优先看到符号位快速判断正负和大小<br>小端:数据高字节在内存低位 可以优先进行计算最后考虑符号位<br>现在intel的80x86用小端<br>ARM芯片默认用小端，可切换到大端<br>MIPS芯片采用大端，可切换<br>网络序为大端<br>XCHG的原理</p>
<h2 id="简写来源"><a href="#简写来源" class="headerlink" title="简写来源"></a>简写来源</h2><ul>
<li>寄存器的ax,bx,cx,dx一般叫做通用寄存器，但也有说法是:Accumulator Base Counter Data    </li>
<li>BX —— based register——基地址寄存器</li>
<li>BP —— base point——基础指针</li>
<li>SI —— source index——源变址寄存器</li>
<li>DI —— destination index——目的变址寄存器<h2 id="待练习"><a href="#待练习" class="headerlink" title="待练习"></a>待练习</h2>vim的使用:以后用vim语法写题</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP向应用层提供一种面向连接的、可靠的字节流服务。<br>面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。<br>在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用于TCP。</p>
<p>二进制整数表示方法:<br>正数的补码是他自己,复数的补码是先用正数表示然后取反+1.<br>两个数相减就是加被减数的补码(取反+1).<br>地址相减:先获得差值,把这个差值转换为int,再用int除法,除以地址指向类型的大小.<br>因此如果地址差值很大,最高位不为0,则会出现虽然a-b应该是正数,但是出现了负数,且相差一个0xf0000000.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Lua-源代码</title>
    <url>/2022/02/04/lua-yuan-dai-ma/</url>
    <content><![CDATA[<h1 id="学习Lua源码"><a href="#学习Lua源码" class="headerlink" title="学习Lua源码"></a>学习Lua源码</h1><p>通过阅读《Lua设计与实现》和Lua源码来学习Lua。<br>首先是下载<a href="http://www.lua.org/ftp/lua-5.2.1.tar.gz" target="_blank" rel="noopener">Lua-5.2.1源代码</a>。<br>把握源码整体结构：</p>
<ul>
<li>Lua源码大体分为三个部分：虚拟机核心、内嵌库、解释器和编译器</li>
</ul>
<p>命名规范：</p>
<ul>
<li>内部模块对外提供的接口、数据结构的命名方式前缀为：<code>luaX_</code>，其中X是模块名简称，比如<code>luaK_</code>、<code>luaG_</code>等</li>
<li>供外部调用的API用<code>lua_</code>前缀</li>
</ul>
<p>然后是各个文件的大致作用的分析，待写xxxxxxxxxxxxx（打算是先把书和源码看了再补充，但是根据以往的经验可能不会再写）  </p>
<h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><p>Lua和Python是动态类型的语言，C/C++是静态类型的语言：</p>
<ul>
<li>静态：一个变量有具体固定的类型，比如<code>int x;</code>对于x来说它的类型就是<code>int</code>，在这个局部作用域是不会变的(可能另一个局部作用域会有同名x，但它已经不是此时的x了)。</li>
<li>动态：<code>x=1</code>变量x的类型现在是整数，但是当另一个语句<code>x=[1,2]</code>之后，x又变成了列表类型，x的类型是<code>attached to</code> 1和<code>[1,2]</code>上的，变的是x的指向而不是x的内容。  <a id="more"></a>

</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Josephus problem(约瑟夫问题)</title>
    <url>/2020/06/26/algo-josephus-problem/</url>
    <content><![CDATA[<h1 id="Josephus-problem（约瑟夫问题）"><a href="#Josephus-problem（约瑟夫问题）" class="headerlink" title="Josephus problem（约瑟夫问题）"></a>Josephus problem（约瑟夫问题）</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>链接：<a href="http://bailian.openjudge.cn/practice/2746/" target="_blank" rel="noopener">http://bailian.openjudge.cn/practice/2746/</a>    </p>
<blockquote>
<p>约瑟夫问题：有ｎ只猴子，按顺时针方向围成一圈选大王（编号从１到ｎ），从第１号开始报数，一直数到ｍ，数到ｍ的猴子退出圈外，剩下的猴子再接着从1开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王，编程求输入ｎ，ｍ后，输出最后猴王的编号。</p>
</blockquote>
<a id="more"></a>
<p>来源：</p>
<ul>
<li>约瑟夫是犹太军队的一个将军，在反抗罗马的起义中，他所率领的军队被击溃，只剩下残余的部队40余人，他们都是宁死不屈的人，所以不愿投降做叛徒。一群人表决说要死，所以用一种策略来先后杀死所有人。</li>
<li>于是约瑟夫建议：每次由其他两人一起杀死一个人，而被杀的人的先后顺序是由抽签决定的，约瑟夫有预谋地抽到了最后一签，在杀了除了他和剩余那个人之外的最后一人，他劝服了另外一个没死的人投降了罗马。</li>
</ul>
<p>那么如何选择一个位置以使得你变成那剩余的最后一人？</p>
<p>这个问题可以转换成递推问题：$J(n,k)=(J(n-1,k)+k)%n$</p>
<ul>
<li>$J(n,k)$表示人数为n，报数节点为k，最后剩下的人的编号。</li>
<li>对于$J(n,k)$,可以转换成 $J(n-1,k)$</li>
<li>当人数为$n$时，进行第一次报数，第$k$个人退出，此时剩余$n-1$个人。</li>
<li>若重新排号，第$k+1$个人为1号，那么此时问题为 $J(n-1,k)$,而此时求出的结果的编号是人数为$n-1$并且重新排号的情况，$J(n,k)$与$J(n-1,k)$编号的关系为 $J(n,k)=(J(n-1,k)+k)%n$ (自行体会)。</li>
</ul>
<p>注意事项：重新编号应该从0开始，最后要和题目的编号方式比较再输出。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++)<span class="comment">//从1推到n</span></span><br><span class="line">        {</span><br><span class="line">            temp = (temp + m) % (i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, temp+<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>约瑟夫变体：求最后x个的编号</p>
<p>链接：<a href="https://vjudge.net/problem/UVA-1452" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-1452</a></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> temp ;</span><br><span class="line">        temp =((m % <span class="number">3</span>)+<span class="number">2</span>)%<span class="number">3</span>;<span class="comment">//剩3个时的编号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n ; i++) <span class="comment">//从3推到n</span></span><br><span class="line">        {</span><br><span class="line">            temp = (temp + m) % (i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        temp = ((m % <span class="number">2</span>)+<span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) <span class="comment">//从2推到n</span></span><br><span class="line">        {</span><br><span class="line">            temp = (temp + m) % (i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp + <span class="number">1</span>);</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">//从1推到n</span></span><br><span class="line">        {</span><br><span class="line">            temp = (temp + m) % (i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, temp + <span class="number">1</span>);</span><br><span class="line">    }  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>








<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>time33</title>
    <url>/2021/02/04/algo-hash/</url>
    <content><![CDATA[<h3 id="字符串hash算法time33"><a href="#字符串hash算法time33" class="headerlink" title="字符串hash算法time33"></a>字符串hash算法time33</h3><p>time33是一种字符串hash算法,其中使用了magic number 5381(001 010 100 000 101)原因是:</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">Magic Constant <span class="number">5381</span>:</span><br><span class="line"><span class="number">1.</span> odd number</span><br><span class="line"><span class="number">2.</span> prime number</span><br><span class="line"><span class="number">3.</span> deficient number</span><br></pre></td></tr></tbody></table></figure>
<p>这些特性使得它hash后的结果分布更好.</p>
<a id="more"></a>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">time33</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> str[]=<span class="string">"hash_func"</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> res=time33(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ud"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">time33</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strx)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash=<span class="number">5381</span>;</span><br><span class="line">    <span class="keyword">while</span>(*strx)</span><br><span class="line">    {</span><br><span class="line">        hash=hash*<span class="number">33</span>+(<span class="keyword">unsigned</span> <span class="keyword">int</span>)*strx;<span class="comment">//或者用位运算</span></span><br><span class="line">        strx++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://www.cnblogs.com/napoleon_liu/articles/1911571.html" target="_blank" rel="noopener">https://www.cnblogs.com/napoleon_liu/articles/1911571.html</a>   </p>
<h2 id="数字hash"><a href="#数字hash" class="headerlink" title="数字hash"></a>数字hash</h2><p>哈希冲突解决办法最常用的就是开发定址法和链地址法。链地址法的原理是如果遇到冲突，就在原地址新建一个空间，然后以链表结点的形式插入到该空间。<br>最主要两个函数:<code>insert</code>和<code>find</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> valid;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">        key = <span class="number">-1</span> * key;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="number">997</span>;</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">hash_table</span>[997];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(struct node *head, <span class="keyword">int</span> value, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;valid == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        head-&gt;key = key;</span><br><span class="line">        head-&gt;value = value;</span><br><span class="line">        head-&gt;valid = <span class="number">1</span>;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    head-&gt;next = (struct node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">    head-&gt;next-&gt;key = key;</span><br><span class="line">    head-&gt;next-&gt;value = value;</span><br><span class="line">    head-&gt;next-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    head-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(struct node *head, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;valid == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;value == value)</span><br><span class="line">                <span class="keyword">return</span> head-&gt;key;</span><br><span class="line">        }</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>cpp中STL的hash表:C++ STL unordered_map容器<br>unordered_map&lt;key,T&gt; tmp;<br>auto it=tmp.find(key);//如果key存在,则返回一个迭代器,如果不存在,则返回尾迭代器tmp.end()<br>it-&gt;second;//表示T<br>it-&gt;first;//表示key</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">auto</span> it=hashtable.find(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=hashtable.end())</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> {it-&gt;second,i};</span><br><span class="line">            }</span><br><span class="line">            hashtable[nums[i]]=i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>offer67</title>
    <url>/2021/02/05/algo-offer67/</url>
    <content><![CDATA[<ol>
<li>二维数组</li>
</ol>
<ul>
<li>如果可以单方向推进就好了</li>
<li>因此需要找一个两个方向的意义不同的点</li>
<li>左下角:大则右移,小则上移</li>
<li>右上角:大则下移,小则左移<a id="more"></a></li>
</ul>
<p>2. </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>permutation(全排列)</title>
    <url>/2020/06/29/algo-permutation-quan-pai-lie/</url>
    <content><![CDATA[<h1 id="全排列的各种输出方法"><a href="#全排列的各种输出方法" class="headerlink" title="全排列的各种输出方法"></a>全排列的各种输出方法</h1><h2 id="最朴素的输出方法"><a href="#最朴素的输出方法" class="headerlink" title="最朴素的输出方法"></a>最朴素的输出方法</h2><ul>
<li>和乘法原理相同的过程，先确定第一位，再确定第二位，以此类推。</li>
<li>回溯</li>
</ul>
<a id="more"></a>


<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> *ma,<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-1</span>==k)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ma[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> temp = ma[i];</span><br><span class="line">        ma[i]=ma[k];       </span><br><span class="line">        ma[k] = temp;</span><br><span class="line">        permutation(ma, n, k + <span class="number">1</span>);</span><br><span class="line">        temp = ma[k];</span><br><span class="line">        ma[k]=ma[i];</span><br><span class="line">        ma[i] = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ma[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    {</span><br><span class="line">        ma[i] = i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    permutation(ma, n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="按照字典序输出"><a href="#按照字典序输出" class="headerlink" title="按照字典序输出"></a>按照字典序输出</h2><ul>
<li>也是先确定第一位，再确定第二位，以此类推</li>
<li>按照字典序要求输出</li>
<li>有约束的深度优先DFS</li>
<li>和朴素的输出方法不同点是：每次交换位置后，后面位置的数要重新排序，按照从小到大排好，由数学归纳法，假设每次交换位置前顺序都是从小到大，交换位置后，则只需要把交换出去的数放在第一位，后面的数依次往后移动一个位置，也保证了第一位最小。</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> *ma,<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-1</span>==k)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ma[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    permutation(ma, n, k + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt; n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> temp = ma[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &gt; k;j--)</span><br><span class="line">        {</span><br><span class="line">            ma[j] = ma[j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">           </span><br><span class="line">        ma[k] = temp;</span><br><span class="line">        permutation(ma, n, k + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        temp = ma[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt;i; j++)</span><br><span class="line">        {</span><br><span class="line">            ma[j] = ma[j + <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        ma[i] = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ma[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    {</span><br><span class="line">        ma[i] = i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    permutation(ma, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>阶乘增长速度比指数还快，很容易爆。</li>
<li>2^16=6,5536 </li>
<li>2^32=42,9496,7296 </li>
<li>2^64=1844,6744,0737,0955,1616</li>
<li>8!=40320 </li>
<li>9！=36,2880 (爆16位unsigned int) </li>
<li>12!=4,7900,1600 </li>
<li>13!=62,2702,0800 (爆32位unsigned int) </li>
<li>20!=243,2902,0081,7664,0000 </li>
<li>21!=5109,0942,1717,0944,0000 (爆64位unsigned long long)<h3 id="康托展开及其逆"><a href="#康托展开及其逆" class="headerlink" title="康托展开及其逆"></a>康托展开及其逆</h3></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>algo-二分查找</title>
    <url>/2022/02/04/algo-er-fen-cha-zhao/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target){ <span class="keyword">return</span> mid; }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) { left = mid + <span class="number">1</span>; }</span><br><span class="line">    <span class="keyword">else</span> { right = mid - <span class="number">1</span>; }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// End Condition: left &gt; right</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p>模板 #1 是二分查找的最基础和最基本的形式。这是一个标准的二分查找模板，大多数高中或大学会在他们第一次教学生计算机科学时使用。模板#1用于查找可以通过访问数组中的单个索引来确定的元素或条件。<br>关键属性:  </p>
<ul>
<li>二分查找的最基础和最基本的形式。</li>
<li>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。</li>
<li>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li>
</ul>
<p>区分语法:  </p>
<ul>
<li>初始条件：left = 0, right = length-1</li>
<li>终止：left &gt; right</li>
<li>向左查找：right = mid-1</li>
<li>向右查找：left = mid+1</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size();</span><br><span class="line">  <span class="keyword">while</span>(left &lt; right){</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    { </span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) </span><br><span class="line">    { </span><br><span class="line">      left = mid + <span class="number">1</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    { </span><br><span class="line">      right = mid; </span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Post-processing:</span></span><br><span class="line">  <span class="comment">// End Condition: left == right</span></span><br><span class="line">  <span class="keyword">if</span>(left != nums.size() &amp;&amp; nums[left] == target) </span><br><span class="line">  <span class="keyword">return</span> left;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>模板 #2 是二分查找的高级模板。它用于查找需要访问数组中当前索引及其直接右邻居索引的元素或条件。<br>比如用在寻找插入位置的情况，即没找到目标，然后插入适当的位置。end=mid,保证了end永远比mid大，当end==begin时还没找到目标，则一定次数end==begin的位置数要大于目标end-1小于目标，则插入到end的位置。<br>关键属性:  </p>
<ul>
<li>一种实现二分查找的高级方法。</li>
<li>查找条件需要访问元素的直接右邻居。</li>
<li>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。</li>
<li>保证查找空间在每一步中至少有 2 个元素。</li>
<li>需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</li>
</ul>
<p>区分语法:  </p>
<ul>
<li>初始条件：left = 0, right = length</li>
<li>终止：left == right</li>
<li>向左查找：right = mid</li>
<li>向右查找：left = mid+1</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right){</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">            left = mid;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>模板 #3 是二分查找的另一种独特形式。 它用于搜索需要访问当前索引及其在数组中的直接左右邻居索引的元素或条件。<br>left=mid保证了left一定小于目标，right=mid保证了right一定大于目标，则当left==right-1时，判断是否找到目标，还没找到目标，则target一定在left和right中间。<br>关键属性:</p>
<ul>
<li>实现二分查找的另一种方法。</li>
<li>搜索条件需要访问元素的直接左右邻居。</li>
<li>使用元素的邻居来确定它是向右还是向左。</li>
<li>保证查找空间在每个步骤中至少有 3 个元素。</li>
<li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。 </li>
</ul>
<p>区分语法</p>
<ul>
<li>初始条件：left = 0, right = length-1</li>
<li>终止：left + 1 == right</li>
<li>向左查找：right = mid</li>
<li>向右查找：left = mid</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>algo-动态规划记录</title>
    <url>/2022/02/04/algo-dong-tai-gui-hua-ji-lu/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>区间dp就是二维数组来限定区间，i-j这个区间由<code>dp[i][j]</code>来表示，i-j区间的答案由i-j之间更小区间决定，此时更小区间往往已经求得。有时解题关键在于分割，或者界限所在。<br>leetcode 664.奇怪的打印机：<a href="https://leetcode-cn.com/problems/strange-printer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/strange-printer/</a><br>这里的特殊的是首位字符的打印，它的特殊在于：它最多被打印一次，第二次打印是多余的，而不像其他位置，可以通过覆盖产生，而不会是多余的打印。<br>第一个字符的打印次序也很特殊，它可以总是被第一个打印：否则，把打印第一个字符的那次打印操作移到第一次进行，可以得到一个次数不会增加的操作序列，结果不变。<br>操作的构造：</p>
<ul>
<li>假设打印首位字符的是第k次操作，这次操作打印n个字符，把这次打印移到第一次进行，设这n个字符最后被保留x个被覆盖y个</li>
<li>覆盖的y个字符由于在k次操作之后的操作被覆盖，因此k次之后的操作序列不变，这部分结果也不变</li>
<li>被保留的x个字符，由于把k次操作以前的字符都覆盖了，因此k次操作之前的字符打印是多余的，除去这部分操作，这部分操作不涉及到前n个字符，则操作次数不会变多  <a id="more"></a>

</li>
</ul>
<p>//贪心：总是从区间的第一个字符开始打印，且字符序列长度为区间长度，然后以被保留的此字符为分界线分割更小的区块，在这基础上打印。错误！！！！<br>//错误！！：因此，打印策略为：从首位字符开始打印，第一次打印覆盖所有位置，再以此为分割分成小块，同样按照这样的策略打印。<br><code>dp[i][j]</code>表示<code>i</code>到<code>j</code>这段字符的打印最少次数，实际上<code>dp[i][j]</code>最小值要么是<code>dp[i][j-1]</code>（不能比这小），要么是<code>dp[i][j-1]+1</code>：假设<code>dp[i][j]</code>比<code>dp[i][j-1]</code>小，则存在一个打印方案，把<code>dp[i][j]</code>打印出来，此时只需要在打印<code>j</code>的那次操作少打印一个字符，便可以打印出<code>dp[i][j-1]</code>,次数更少，矛盾。而如果打印方案不是<code>dp[i][j-1]</code>，则在<code>dp[i][j-1]</code>基础上再打印最后一个字符便可以得到<code>dp[i][j]</code>，因此次数最多+1。同理<code>dp[i][j]</code>不能比<code>dp[i+1][j]</code>小。<br>合并两个区间的关键在于分界线，如果最优打印存在一个分界线，分界线两边的打印总是不会跨过这条线，则大区间的最优打印次数等于两边小区间的最优次数之和。<br>而如果一条线的两边没有相同的字符，比如左边有a右边没有a，则打印a的这次操作没有必要跨过这条分界线，意味着，如果首尾的字符不同，则一定存在这样的最优分界线。这个时候去遍历这条最优分界线就行了。<br>进一步，这条分界线一定在与<code>s[i]</code>字符相同的一个地方，否则分界线还可以更多。<br>而如果首尾字符相同，则可以把打印第一个字符和最后一个字符的操作连在一起，移到第一次打印，则<code>dp[i][j]=dp[i][j-1]</code><br>并且相邻的两个dp最多只相差1，因为相邻的两个总是可以互相从另一个多打印一次得到。<br>因此<code>min(dp[i][j-1],dp[i+1][j])+1&gt;=dp[i][j]&gt;=min(dp[i][j-1],dp[i+1][j])</code>，或者<code>max(dp[i][j-1],dp[i+1][j])+1&gt;=dp[i][j]&gt;=max(dp[i][j-1],dp[i+1][j])</code>，是一样的。实际上只要相邻两个dp数值不同，则取大的那个就行了；如果数值相同，则需要判断，如果首尾相同的话，则可以省去一次打印，可以取最小值。 </p>
<pre class="line-numbers language-cpp"><span class="class"><span class="keyword">class</span> <span class="title"><code class="language-cpp"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>
<span class="class">{</span>
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(<span class="built_in">string</span> s)</span></span>
<span class="function">    </span>{
        <span class="keyword">if</span> (s.size() < <span class="number">1</span>)
            <span class="keyword">return</span> <span class="number">0</span>;
       <span class="keyword">int</span> dp[s.size()][s.size()];
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < s.size(); i++)
        {
            dp[i][i] = <span class="number">1</span>;
        }
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < s.size(); i++)
        {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < s.size() - i; j++)
            {

                    <span class="keyword">if</span>(s[j]==s[i+j])
                    {
                        dp[j][i + j] = dp[j][i + j - <span class="number">1</span>];
                        <span class="keyword">continue</span>;
                    }
                    dp[j][i + j] = dp[j][i + j - <span class="number">1</span>] + <span class="number">1</span>;
                    <span class="keyword">for</span> (<span class="keyword">int</span> n = j ; n < i + j;n++)
                    {
                        <span class="keyword">if</span>(s[j]==s[n])
                        dp[j][i + j] = min(dp[j][i + j],dp[j][n] + dp[n+<span class="number">1</span>][j+i]);
                    }
            }
            }
        <span class="keyword">return</span> dp[<span class="number">0</span>][s.size() - <span class="number">1</span>];
    }
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>单调栈(monotone stack)</title>
    <url>/2020/10/14/algo-dan-diao-zhan-monotone-stack/</url>
    <content><![CDATA[<h1 id="monostone"><a href="#monostone" class="headerlink" title="monostone"></a>monostone</h1><ul>
<li>单调栈顾名思义就是一个储存元素单调排列的栈，可以是单调递增也可以是单调递减的</li>
<li>单调栈可以解决的问题是：对于于一个数列，可以在线性时间内找到每一个数的下一个比自己大的或者小的数  <a id="more"></a></li>
<li>比如：$2 3 5 7 8 6 5 1$。对于$2$来说，下一个比它小的数是$1$，对于$8$来说下一个比它小的数是6.</li>
<li>朴素的算法是复杂度为$O(n^2)$。并且有两个：<ul>
<li>$\alpha.$ 第一种方法，往后遍历：对于$2$来说，遍历$2$后面的所有数找出第一个比它小的数</li>
<li>$\beta.$ 第二种方法，往前遍历：对于$5$来说，往左遍历，找到第一个比它小或者相等的数$x$,此时$x$和$5$之间的数的下一个比自己小的数就是$5$,而对于$5$来说$x$之前的数被$x$屏蔽了。</li>
</ul>
</li>
<li>而使用单调栈可以使复杂度降低为$O(n)$   </li>
<li>还是上面的数列，找第一个比自己小的数：<ul>
<li>$\alpha.$维持一个单调递增的栈，当遇到一个新值 $x$ 时，如果这个值比栈顶的值 $y$ 大或者相等，压入;</li>
<li>$\beta.$如果 $x$ 比 $y$ 小，那么把 $y$ 弹出，并且把这个 $y$ 对应的输出置为 $x$ ，回到 $\alpha$</li>
</ul>
</li>
<li>单调栈的原理在于：<ul>
<li>对于每一个数，它被选中之后就会被弹出不会被重复遍历，总体的查询次数最多是$2n$，压栈的时候要主动去查询一次栈顶元素查询次数就是$n$，然后如果命中了，需要弹栈再查询,总共需要弹$n$次 ，保证了复杂度是$O(n)$</li>
<li>对于 $x、y$，如果$x\leq y$那么对于$x$前面的数对于$y$来说就是不可见的，或者被$x$屏蔽了,所以不用遍历了</li>
</ul>
</li>
</ul>
<hr>
<h2 id="几道leetcode"><a href="#几道leetcode" class="headerlink" title="几道leetcode"></a>几道leetcode</h2><p>$\alpha.$ $739 Daily Temperatures$ <a href="https://leetcode.com/problems/daily-temperatures/" target="_blank" rel="noopener">https://leetcode.com/problems/daily-temperatures/</a>  </p>
<blockquote>
<p>Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.<br>For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].<br>Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].</p>
</blockquote>
<ul>
<li>很显然的单调栈  </li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;T)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; small_stk;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(T.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T.size();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(small_stk.empty())</span><br><span class="line">            {</span><br><span class="line">                small_stk.push(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }           </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(T[i]&lt;=T[small_stk.top()])</span><br><span class="line">            {</span><br><span class="line">                small_stk.push(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(T[i]&gt;T[small_stk.top()])</span><br><span class="line">            {</span><br><span class="line">                ret[small_stk.top()] = i - small_stk.top();</span><br><span class="line">                small_stk.pop();</span><br><span class="line">                <span class="keyword">while</span>(!small_stk.empty() &amp;&amp;T[i]&gt;T[small_stk.top()])</span><br><span class="line">                {</span><br><span class="line">                    ret[small_stk.top()] = i - small_stk.top();</span><br><span class="line">                  </span><br><span class="line">                    small_stk.pop();</span><br><span class="line">                }</span><br><span class="line">                small_stk.push(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!small_stk.empty())</span><br><span class="line">        {</span><br><span class="line">            ret[small_stk.top()] = <span class="number">0</span>;</span><br><span class="line">            small_stk.pop();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;T={<span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">71</span>, <span class="number">69</span>, <span class="number">72</span>, <span class="number">76</span>, <span class="number">73</span> };</span><br><span class="line">    Solution A;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;x=A.dailyTemperatures(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.size();i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>$\beta.$ $84.Largest:Rectangle:in:Histogram$ <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a>  </p>
<ul>
<li>还有几道题明天写</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>algo-各种和</title>
    <url>/2022/02/04/algo-ge-chong-he/</url>
    <content><![CDATA[<h1 id="分割和"><a href="#分割和" class="headerlink" title="分割和"></a>分割和</h1><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">leetcode 416.分割等和子集</a><code>01</code>背包，指定背包容量。<br>背包递归写法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> va[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ma[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> nums,<span class="keyword">int</span> cap)</span>    </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(nums&lt;<span class="number">0</span>||cap&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ma[nums][cap]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ma[nums][cap];</span><br><span class="line">    <span class="keyword">return</span> dp(nums - <span class="number">1</span>, cap - va[nums]) + va[nums] &lt; dp(nums - <span class="number">1</span>, cap) ? dp(nums - <span class="number">1</span>, cap) : dp(nums - <span class="number">1</span>, cap - va[nums]) + va[nums];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<p>背包循环写法：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ma[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> ca[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">1005</span>];</span><br><span class="line"><span class="built_in">memset</span>(ma,<span class="number">0</span>,<span class="keyword">sizeof</span>(ma));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cap;j++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(j&lt;ca[i])</span><br><span class="line">        ma[i][j]=ma[i<span class="number">-1</span>][j];</span><br><span class="line">        ma[i][j]=max(ma[i<span class="number">-1</span>][j],ma[i<span class="number">-1</span>][j-ca[i]]+w[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//一种更好的for写法,i表示第i件物品，j表示容量，当j小于当前物品容量时，不改变值，是原来的值，即i-1的值</span></span><br><span class="line">    <span class="comment">//但是使用二维数组会出错，以为此时没有更新i时的值，因此需要用一维数组，表示上一轮的最优解，因为每次只需要用到上一轮的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=cap;j&gt;=va[i];j--)</span><br><span class="line">    {</span><br><span class="line">        ma[i][j]=max(ma[i<span class="number">-1</span>][j],ma[i<span class="number">-1</span>][j-ca[i]]+w[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//因此应该使用空间优化后的一维数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=cap;j&gt;=va[i];j--)</span><br><span class="line">    {</span><br><span class="line">        ma[j]=max(ma[j],ma[j-ca[i]]+w[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>algo-搜索</title>
    <url>/2022/02/04/algo-sou-suo/</url>
    <content><![CDATA[<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>树的广度优先遍历的写法模式相对固定： </p>
<ul>
<li>使用队列；</li>
<li>在队列非空的时候，动态取出队首元素；</li>
<li>取出队首元素的时候，把队首元素相邻的结点（非空）加入队列。  <a id="more"></a>

</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!deq.empty())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> len = deq.size();</span><br><span class="line">            ret.push_back({});</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">auto</span> tmp = deq.front();</span><br><span class="line">                deq.pop_front();</span><br><span class="line">                ret.back().push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                {</span><br><span class="line">                    deq.push_back(tmp-&gt;left);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                {</span><br><span class="line">                    deq.push_back(tmp-&gt;right);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">           }</span><br></pre></td></tr></tbody></table></figure>
<p>在无权图中，由于广度优先遍历本身的特点，假设源点为 source，只有在遍历到所有距离源点source的距离为d的所有结点以后，才能遍历到所有距离源点 source的距离为d + 1的所有结点。也可以使用「两点之间、线段最短」这条经验来辅助理解如下结论：从源点 source 到目标结点 target 走直线走过的路径一定是最短的。<br>对于图的广度优先遍历，先建立链式邻接表，然后从第一个链开始搜索，完成之后搜索第二个链，如果已被访问，则跳过。  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>algo-暴力</title>
    <url>/2022/02/04/algo-bao-li/</url>
    <content><![CDATA[<p>对于有的题，如果实在没有办法就只有暴力搜索了，特别是取或者不取某个元素的时候。<br>观察数据，当数据量小的时候就用暴力。   </p>
<blockquote>
<p>现在有n个物品，每个物品都有一个价值，现在想将这些物品分给两个人，要求这两个人分到的物品价值总和相同(个数可以不同，总价值相同即可)，剩下的物品就要扔掉，现在想知道最少需要扔多少价值的物品才能满足要求分给两个人。</p>
</blockquote>
<blockquote>
<p>输入描述第一行输入一个整数T，代表有T组测试数据 对于每一组测试数据，一行输入一个整数n，代表物品的个数 接下来n个数，a[i]代表每一个物品的价值 1 &lt;= T &lt;= 10 1 &lt;= n &lt;= 15 1 &lt;= a[i] &lt;= 100000 输出描述每一行输出最少需要扔掉多少价值的物品示例1输入1530 60 5 15 30输出20说明</p>
</blockquote>
<blockquote>
<p>样例解释，扔掉第三个和第四个物品，然后将第一个物品和第五个物品给第一个人，第二个物品给第二个人，每个人分到的价值为60，扔掉的价值为20。</p>
</blockquote>
<a id="more"></a>

<p>因为n最大是15，这个时候可以暴力搜索，用深度优先，如果最后两个集合的值相等，则记录。  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sum1, <span class="keyword">int</span> sum2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(sum1==sum2)</span><br><span class="line">        {</span><br><span class="line">            ret=min(ret, sum-sum1-sum2);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    dfs(index+<span class="number">1</span>,sum1+ma[index],sum2);</span><br><span class="line">    dfs(index+<span class="number">1</span>,sum1,sum2+ma[index]);</span><br><span class="line">    dsf(index+<span class="number">1</span>,sum1,sum2);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>最大子序和</title>
    <url>/2020/11/01/algo-zui-da-zi-xu-he/</url>
    <content><![CDATA[<h2 id="简单的线性规划"><a href="#简单的线性规划" class="headerlink" title="简单的线性规划"></a>简单的线性规划</h2><ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></li>
<li>$dp[i]$代表以当前数结尾的序列最大和</li>
<li>转移方程是$dp[i]=max{dp[i-1]+xi , xi}$<a id="more"></a></li>
<li>动态规划代码$O(n)$  </li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[nums.size()];</span><br><span class="line">        <span class="keyword">int</span> maxn = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i] &gt; nums[i] ? dp[i - <span class="number">1</span>] + nums[i] : nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;maxn)</span><br><span class="line">            {</span><br><span class="line">                maxn = dp[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/2020/10/30/algo-zui-chang-shang-sheng-zi-xu-lie/</url>
    <content><![CDATA[<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><ul>
<li>leetcode300 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a>  </li>
<li>动态规矩、线性动态规划（一维）<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2></li>
<li>暴力：遍历每一个子集中的元素,遍历$2^n$次</li>
<li>$O(n^2)$复杂度的动态规划：<ul>
<li>$dp[i-1]$代表第$i$个元素作为序列最后一个数时，最大的上升子序列长度；当遍历第$i$个数时$dp[i]=max{dp[j]+1(j&lt;i,xj&lt;xi)}$</li>
<li>证明，归纳法（假设序号从1开始）：<ul>
<li>$i=1$时显然成立；</li>
<li>当$i&lt;n$时假设成立：$dp[i]$表示$i$个元素作为序列最后一个数时，最大的上升子序列长度;</li>
<li>$i=n$时，若$dp[n]$不是以$xn$结尾的最大上升序列，即存在另一个以$xn$结尾的最大上升序列，而这个序列去掉$xn$后一定属于$dp[n]$之前的一个序列，而$dp[n]$是里面符合情况最好的，矛盾。</li>
</ul>
</li>
</ul>
</li>
<li>$O(nlgn)$复杂度的动态规划：<ul>
<li>$dp[i]$代表$i+1$长度的上升序列中，末尾最小的那个序列的末尾数，显然$dp[i]$是单调上升的（假设不单调上升，存在一个$i$,$dp[i]&gt;=dp[i+1]$则让$dp[i+1]$代表的那个序列去掉末尾，则新的末尾小于$dp[i]$矛盾），当遍历到$xj$时，用二分法找到$dp[i-1]&lt;xj&lt;=dp[i]$插入并把$dp[i]$的值更新为$xj$（新的长度为$i+1$符合条件的序列是：长度为$i$的末尾最小序列$+xj$）,如果$xj$是最大的，$maxlen++$,$dp[maxlen]=xj$这个代表的序列是$dp[maxlen-1]$代表的那个序列$+xj$。</li>
<li>证明：归纳法+反证法或者推理。</li>
<li>二分查找：begin=mid+1, end=mid;</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">{</span><br><span class="line">    mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[mid] == nums[i])</span><br><span class="line">    {</span><br><span class="line">        hi = mid;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dp[mid] &lt; nums[i])</span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//mid的比较方向对最后的结果也会有影响：</span></span><br><span class="line">        <span class="comment">//如果先判断目标数是在mid-hi之间</span></span><br><span class="line">        <span class="comment">//那么最后结果会是最终的hi的位置不小于目标数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        hi = mid;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>$O(n^2)$</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="keyword">int</span> max_LIS=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">           {</span><br><span class="line">               <span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">               {</span><br><span class="line">                   <span class="keyword">if</span>(dp[j]&gt;maxn)</span><br><span class="line">                   {</span><br><span class="line">                       maxn=dp[j];</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           dp.push_back(maxn+<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span>(max_LIS&lt;dp[i])</span><br><span class="line">           max_LIS=dp[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> max_LIS;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>$O(nlgn)$</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> lo = <span class="number">0</span>, hi = dp.size();</span><br><span class="line">            <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi)</span><br><span class="line">            {</span><br><span class="line">                mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[mid] == nums[i])</span><br><span class="line">                {</span><br><span class="line">                    hi = mid;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dp[mid] &lt; nums[i])</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    hi = mid;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (hi == dp.size())</span><br><span class="line">            {</span><br><span class="line">                dp.push_back(nums[i]);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                dp[hi] = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>algo-遇到的奇怪问题</title>
    <url>/2022/02/04/algo-yu-dao-de-qi-guai-wen-ti/</url>
    <content><![CDATA[<p>leetcode里写在类外面的数组，可能不会被成功初始化，原因是多个样例会多次调用同一个方法，而类的初始化只有一次。  </p>
<a id="more"></a>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">10000</span>] = {<span class="number">0</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>{  </span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如果没有memset的话不一定为0。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>鸡蛋掉落</title>
    <url>/2020/11/02/algo-ji-dan-diao-luo/</url>
    <content><![CDATA[<h2 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a>鸡蛋掉落</h2><ul>
<li><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/super-egg-drop/</a></li>
<li>$dp[i][j]$表示$i-1$个鸡蛋，$j$层楼，最少的步数</li>
<li>$dp[i][j]=1+min{max{dp[i-1][k-1],dp[i][j-k]},1&lt;=k&lt;=j}$</li>
<li>状态转移方程所采取的策略是：遍历第一次扔鸡蛋的楼层，然后选取其中需要扔鸡蛋次数最少的方案，而在每某层扔鸡蛋的最少次数是1+$max{dp[i-1][k-1],dp[i][j-k]$</li>
<li>优化：<ul>
<li>可以看到对于固定的$j$,即固定的楼数，当k增大时$dp[i-1][k-1]$增大，$dp[i][j-k]$减小，因此这是一个交叉的单调函数，有最优点，为交叉点，可以用二分法求出交叉点复杂度从$O(n)$变成了$O(lgn)$</li>
<li>当$k$固定，$j$增大时，$dp[i-1][k-1]$不变，$dp[i][j-k]$变大，因此交叉点一定是单调的，因此可以用一个变量记录交叉点 ，只需要单增检验就行了</li>
</ul>
</li>
<li>反向：$dp[i][j]$表示$i-1$个鸡蛋，$j$次扔鸡蛋，最大可以确定多少层楼<ul>
<li>$dp[i][j]=dp[i][j-1]+dp[i-1][j-1]+1$</li>
<li>此转移方程的策略是：站在$dp[i-1][j-1]+1$层扔，如果碎了，变成$dp[i-1][j-1]$,如果没碎，变成$dp[i][j-1]$,不管碎没碎，都可以保证检验$dp[i][j-1]+dp[i-1][j-1]+1$层楼<a id="more"></a>


</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[K][N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N + <span class="number">1</span>;j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                {</span><br><span class="line">                    dp[i][j] = j;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(j&lt;=<span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    dp[i][j] = j;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">0</span>, hi = j;</span><br><span class="line">                <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span>(lo&lt;hi)</span><br><span class="line">                {</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dp[i][mid] == dp[i - <span class="number">1</span>][j - mid - <span class="number">1</span>])</span><br><span class="line">                    {</span><br><span class="line">                        lo = mid;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][mid]&lt;dp[i<span class="number">-1</span>][j-mid<span class="number">-1</span>])</span><br><span class="line">                    {</span><br><span class="line">                        lo = mid + <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][mid] &gt; dp[i - <span class="number">1</span>][j - mid - <span class="number">1</span>])<span class="comment">//一定成立</span></span><br><span class="line">                    {</span><br><span class="line">                        hi = mid;</span><br><span class="line">                    }</span><br><span class="line">                    mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                }</span><br><span class="line">               </span><br><span class="line">                dp[i][j] = dp[i][lo] &lt; dp[i - <span class="number">1</span>][j - lo] ? dp[i][lo] + <span class="number">1</span> : dp[i - <span class="number">1</span>][j - lo]+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[K - <span class="number">1</span>][N];</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    Solution x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;x.superEggDrop(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span> <span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> dp2[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=N;i++)</span><br><span class="line">        {</span><br><span class="line">           dp2[i]= dp[i] = i;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; K;k++)</span><br><span class="line">        {</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>, j = <span class="number">1</span>; i &lt;=N; i++)</span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (max(dp[j - <span class="number">1</span>], dp2[i - j]) &gt; max(dp[j], dp2[i - j - <span class="number">1</span>])&amp;&amp; j&lt;i)</span><br><span class="line">                {</span><br><span class="line">                    j++;</span><br><span class="line">                }</span><br><span class="line">                dp[i] = max(dp[j - <span class="number">1</span>], dp2[i - j])+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==N)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;=N;m++)</span><br><span class="line">                        dp2[m] = dp[m];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> dp[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++)</span><br><span class="line">        {</span><br><span class="line">            dp[i] = i + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; K;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">int</span> temp1, temp2=dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;N;j++)</span><br><span class="line">            {</span><br><span class="line">                temp1 = dp[j];</span><br><span class="line">                dp[j] = temp2 + dp[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                temp2 = temp1;</span><br><span class="line">                <span class="keyword">if</span>(dp[j]&gt;N)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dp[i]&lt;N)</span><br><span class="line">        {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>DP</category>
        <category>线性DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>c-宏</title>
    <url>/2022/02/04/c-hong/</url>
    <content><![CDATA[<p>单<code>#</code>号意思是把其后面的宏参数字符串化，即两边加上引号，变为字符串：<br><code>#define PRINT_ERR(EXP) fprintf(stderr,"WARNING:"#EXP"\n");</code>当使用<code>PRINT_ERR(divder==0)</code>就会打印<code>"WARNING:divider==0\n"</code><br><code>##</code>把两个token连成一个，或者说把两个字符连成一个：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_TRAP(n) printf(<span class="meta-string">"trap"</span>#n<span class="meta-string">" = %d\n"</span>,trap##n);</span></span><br><span class="line"><span class="keyword">int</span> trap10=<span class="number">10</span>;</span><br><span class="line">PRINT_TRAP(<span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>结果会打印<code>"trap10=10\n"</code>  </p>
<a id="more"></a>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>cmu-15-445</title>
    <url>/2021/02/04/cmu-15-445/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>cmu-database</title>
    <url>/2022/02/04/cmu-database/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>课程大纲：</p>
<ul>
<li>关系型数据库</li>
<li>存储</li>
<li>执行</li>
<li>同步控制</li>
<li>恢复</li>
<li>分布式数据库</li>
</ul>
<p>例子：歌手和专辑的数据库</p>
<ul>
<li>歌手表：名字、出生年份、国籍</li>
<li>专辑表：名字、歌手、年份</li>
</ul>
<p>数据库的一些问题：</p>
<ul>
<li>如果有人用非法的字符串改写了创作时间怎么办？</li>
<li>如果一个专辑有多个歌手怎么办？</li>
<li>如果删除了一个拥有专辑的歌手会发生什么？</li>
<li>怎么找到一个特定的记录？</li>
<li>如果现在想创建一个新的使用同一个数据库的应用程序该怎么办？</li>
<li>如果两个线程同时想要写同一个文件该怎么办？</li>
<li>如果在我们想要更新一个记录时机器崩溃了该怎么办？</li>
<li>如果我们在多机器上为了高可达性复制数据库该怎么办？<a id="more"></a>

</li>
</ul>
<p>数据库管理程序是一个允许应用程序在数据库中存储和分析信息的软件<br>一个通用数据库管理程序被设计成允许定义、创建、查询、更新和管理数据库  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>cpp-codemem</title>
    <url>/2022/02/04/cpp-codemem/</url>
    <content><![CDATA[<p> /*</p>
<p> <em>/<br> // 不包括结尾的’\0’<br>// 注意参数是const char</em> 而不是void*<br> int strlen(const char *s)<br> {<br>     int n;<br>     for (n = 0; *s != ‘\0’; n++, s++)<br>         ;<br>     return n;<br>}</p>
<a id="more"></a>

<pre><code>// 功能：获取字符串s中实际字符个数，不包括结尾的'\0'；
// 如果实际个数 &lt;= maxlen，则返回n，否则返回第二个参数。
// 注意参数是const char* 而不是void*
int strnlen(const char *s, size_t size)</code></pre><p>{<br>    int n;<br>    for (n = 0; size &gt; 0 &amp;&amp; <em>s != ‘\0’;size–,s++)<br>        n++;<br>    return n;<br>}<br>// 注意第二个参数是const char</em> 而不是char*<br>char* strcpy(char<em>dst,const char</em> src)<br>{<br>    char <em>ret = dst;<br>    for (; *src != ‘\0’;)<br>    {<br>        *dst++ = *src++;<br>    }<br>    return ret;<br>}<br>char</em> strcat(char<em>dst, const char</em>src)<br>{<br>    int n = strlen(src);<br>    strcpy(dst+n, src);<br>    return dst;<br>}<br>char<em>strncpy(char</em>dst, const char<em>src,size_t size)<br>{<br>    size_t i;<br>    char *ret=dst;<br>    for (i = 0; i &lt; size ;i++)<br>    {<br>        *dst++ = *src;<br>        if(</em>src!=’\0’)<br>            src++;</p>
<pre><code>}

return dst;</code></pre><p>}<br>void <em>memmove(void</em>dst,const void*src,size_t size)<br>{</p>
<pre><code>char *d = (char *)dst;
const char *s = (const char *)src;
if(s&lt;d&amp;&amp;d-s&lt;size)
{
    s += size;
    d += size;
    while(size--)
    {
        *d-- = *s--;
    }
}
    else {
        *d++ = *s++;
    }
    return dst;</code></pre><p>}<br>int partition(int *a,int begin,int end)<br>{<br>    if(begin==end)<br>        return end;<br>    int x = a[end];<br>    int index = begin - 1;<br>    for (int i = begin; i &lt; end;i++)<br>    {<br>        if(a[i]&lt;=x)<br>        {<br>            index++;<br>            swap(a[i], a[index]);<br>        }</p>
<pre><code>}
index++;
swap(a[index], a[end]);
return index;</code></pre><p>}</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>C++ unordered_map</title>
    <url>/2021/02/15/cpp-unordered-map/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>cpp 容器</title>
    <url>/2021/02/16/cpp-rong-qi/</url>
    <content><![CDATA[<p>一个容器就是一些特定类型对象的集合.<br>顺序容器为程序员提供了控制元素存储和访问顺序的能力.这种顺序不依赖于元素的值,而是与元素加入容器时的位置相对应.<br>相对的,有序和无序关联容器,则根据关键字的值来存储元素.<br>标准库还提供了三种容器适配器,分别为容器操作定义了不同的接口,来与容器类型适配.容器适配器是标准库中的一个通用概念.容器,迭代器和函数都有适配器.<br>本质上,一个适配器是一种机制,能使某种事物的行为看起来像另一种事物一样.<br>一个容器适配器接受一种已有的容器类型,使其行为看起来像一种不同的类型.例如<code>stack</code>适配器接受一个顺序容器(<code>array</code>或<code>forward_list</code>除外),并使其操作起来像一个stack一样.</p>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><a id="more"></a>
<h2 id="容器的选择"><a href="#容器的选择" class="headerlink" title="容器的选择"></a>容器的选择</h2><h2 id="容器公有的操作"><a href="#容器公有的操作" class="headerlink" title="容器公有的操作"></a>容器公有的操作</h2><p>一般来说每个容器都定义在一个头文件中,文件名与类型名相同.容器均为模板类,需要额外的类型信息生成特定的容器.<br>顺序容器几乎可以保存任意类型的元素,特别是我们可以定义一个容器,其元素类型是另一个容器.<code>vector&lt;vector&lt;int&gt;&gt;</code><br>但是某些容器操作对元素类型有自己的特殊要求,如果某种类型不支持这种特殊操作,也可以定义这种容器,但是只能使用没有特殊要求的操作了:比如顺序容器的某个构造函数可以接受容器大小参数,它使用了元素的默认构造函数,而如果容器的元素没有实现这个默认构造函数,将不能用这个操作.  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;noDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,init)</span></span>;<span class="comment">//正确,提供了元素初始化器</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;noDefault&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//错误,必须提供一个元素初始化器,或者提供一个默认构造函数</span></span><br></pre></td></tr></tbody></table></figure>
<p>共有的操作:</p>
<ul>
<li>iterator 此容器类型的迭代器类型</li>
<li>const_iterator 可以读取元素,但是不能修改元素,是一个迭代器类型</li>
<li>size_type 无符号整数类型,足够保存此种容器类型最大可能大小<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2>迭代器类似与指针，提供了对对象的间接访问，并可以通过<code>++</code>和<code>--</code>从一个元素移动到另一个元素，通过解引用<code>*</code>来获取元素。<br>有迭代器的类型同时拥有返回迭代器的成员，这些类型都有名为<code>begin</code>和<code>end</code>的成员。<br><code>begin</code>成员负责返回指向第一个元素的迭代器，<code>end</code>负责返回指向容器“尾元素的下一个位置”的迭代器，也就是说该迭代器指向的是容器的一个本不存在的“尾后”元素。<br>尾后迭代器没有什么实际含义，仅仅是个标记，对尾后迭代器解引用会出现未定义的行为。<br>如果容器为空，<code>begin</code>和<code>end</code>返回的都是尾后迭代器。  <h3 id="迭代器的运算符"><a href="#迭代器的运算符" class="headerlink" title="迭代器的运算符"></a>迭代器的运算符</h3><code>*iter</code>返回迭代器iter指向元素的引用（不可对尾后迭代器解引用）<br><code>iter-&gt;mem</code>解引用iter并获取该元素名为mem的成员，等价于<code>(*iter).mem</code><br><code>++</code>、<code>--</code>指向容器中的上一个（下一个）元素，<code>forward_list</code>不支持递减<br><code>==</code>、<code>!=</code>判断两个迭代器是否相等（指向同一个元素）。  <h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3>我们并不需要知道迭代器的准确类型（即返回的类型，int* char*等)，而可以直接通过<code>类名::iterator</code>来获取：<br><code>vector&lt;int&gt;::iterator it;</code><br><code>string::iterator it2;</code><br><code>vector&lt;int&gt;::const_iterator it3</code><br><code>string::const_iterator it4;</code><br>const_iterator和常量指针类似，能读取但是不能修改元素。<br><code>cbegin</code>和<code>cend</code>来返回<code>const_iterator</code>。  <h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3>某些对vector对象的操作会使迭代器失效，当vector容量变化时，迭代器都有可能失效。<br>任何能引起vector容量变化的操作，比如<code>push_back</code>都可能使迭代器失效。  </li>
<li><em>谨记*</em>：任何使用迭代器的循环体，都不要向迭代器所属的容器中添加元素，这有可能会导致迭代器失效。（因为迭代器和容器元素指针有关，容器扩容时可能会改变元素地址）<br>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针引用或迭代器失效，一个失效的指针、引用或迭代器将不再表示任何元素，使用它们会引起和未初始化指针一样的问题。  </li>
</ul>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector:可变大小数组,支持快速随机访问,在尾部之外的位置插入或者删除元素可能很慢.<br>vector的实现:</p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>双端队列.支持快速随机访问,在头尾插入/删除速度很快</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>双向链表.只支持shuang’xiang顺序访问.在任何位置插入删除速度都很快.</p>
<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p>单向链表.只支持单向顺序访问.在链表任何位置进行插入删除速度都很快.</p>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>固定大小数组.支持随机快速访问.不能添加或删除元素.</p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>与<code>vector</code>相似的容器.但专门用于保存字符.随机访问快.在尾部插入删除速度快.</p>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器有着根本的不同:关联容器中的元素是按关键字来保存和访问的.<br>关联容器支持高效的关键字查找和访问.两个主要的关联容器类型是<code>map</code>和<code>set</code>.<br><code>map</code>中的元素是一些关键字-值对:关键字起索引的作用,值则表示与索引相关联的数据.<br><code>set</code>中每个元素只包含一个关键字,它支持高效的关键字查询操作,检查一个给定关键字是否在set中.<br>在某些文本处理过程中,可以用一个set来保存想要忽略的单词.<br>map可以实现字典:用单词作为关键字,单词释义作为值.<br>标准库提供8个关联容器.这8个关联容器的不同体现在三个方面:  </p>
<ol>
<li>每个容器要么是一个set,要么是一个map</li>
<li>要么允许重复关键字,要么不允许重复关键字.允许重复关键字的容器的名字中都包含单词<code>multi</code></li>
<li>要么按顺序保存元素,要么无序保存元素.不保持关键字顺序的容器都以单词<code>unordered</code>开头.<br>因此:  </li>
<li><code>map</code>:保持元素顺序不允许重复的map</li>
<li><code>set</code>:保持元素顺序不允许重复的set</li>
<li><code>multimap</code>:保持元素顺序允许重复的map</li>
<li><code>multimap</code>:保持元素顺序允许重复的set</li>
<li><code>unordered_map</code>:不保持元素顺序不允许重复的map</li>
<li><code>unordered_set</code>:不保持元素顺序不允许重复的set</li>
<li><code>unordered_multimap</code>:不保持元素顺序允许重复的map</li>
<li><code>unordered_multiset</code>:不保持元素顺序允许重复的set<br><code>map</code>和<code>multimap</code>在头文件<code>map</code>里,<code>set</code>和<code>multiset</code>在头文件<code>set</code>里.无序容器在头文件<code>unordered_map</code>和<code>unordered_set</code>里.    <h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3>经典的使用<code>map</code>的例子是单词计数器:  <figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现的次数</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;<span class="comment">//string到size_t的空map</span></span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;word)</span><br><span class="line">++word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; w:word_count)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;w.first&lt;&lt;<span class="string">" occurs "</span>&lt;&lt;w.second&lt;&lt;((w.second&gt;<span class="number">1</span>?<span class="string">" times"</span>:<span class="string">" time"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
此程序读取输入,报告每个单词出现多少次.<br>当对word_count进行下标操作时,word还未在map中,下标运算会创建一个新元素,关键字为word,值为0(值初始化).<br><code>for(const auto&amp;w:word_count)</code>中w会得到一个<code>pair</code>类型的对象.  <h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><code>pair&lt;set&lt;int&gt;::iterator, bool&gt; set&lt;int&gt;::insert(int key_value);</code>插入函数，通过键值插入，返回一个pair，first代表插入元素的迭代器，second代表是否插入成功，插入失败是指此元素以及在set里了。<br><code>inset(first,second);</code>将定位器（地址）<code>[first,second)</code>的元素插入到set中，返回值是void<br><code>set&lt;int&gt;::iterator find(int key_value);</code>通过键值查找是否存在这个元素，存在则返回所在迭代器，不存在返回一个尾后迭代器。<br><code>erase(iterator)</code>删除定位器<code>iterator</code>指向的值<br><code>erase(first,second)</code>删除定位器<code>[first,second)</code>的值<br><code>erase(key_value)</code>删除键值<code>key_value</code>的值<br><code>lower_bound(key_value)</code>返回第一个大于等于key_value的定位器<br><code>upper_bound(key_value)</code>返回最后一个大于等于key_value的定位器<br>自定义比较函数:  </li>
</ol>
<ul>
<li>元素不是结构体：<br>//自定义比较函数myComp,重载“()”操作符<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myComp</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> your_type &amp;a,<span class="keyword">const</span> your_type &amp;b)</span></span></span><br><span class="line">    [</span><br><span class="line">        <span class="keyword">return</span> a.data-b.data&gt;<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,myComp&gt;s;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,myComp&gt;::iterator it;</span><br></pre></td></tr></tbody></table></figure></li>
<li>如果元素是结构体，可以直接将比较函数写在结构体内  <figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="comment">//重载“&lt;”操作符，自定义排序规则</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Info &amp;a) <span class="keyword">const</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//按score从大到小排列</span></span><br><span class="line">        <span class="keyword">return</span> a.score&lt;score;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">set</span>&lt;Info&gt; s;</span><br><span class="line">......</span><br><span class="line"><span class="built_in">set</span>&lt;Info&gt;::iterator it;</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>单词统计程序的合理拓展是:忽略常见单词,如”the”,”and”,”or”等.可以使用set保存想忽略的单词,只对不在集合中的单词统计出现次数:  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//统计每个单词在输入中出现的次数</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;<span class="comment">//string到size_t的空map</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude={<span class="string">"the"</span>,<span class="string">"but"</span>, <span class="string">"or"</span>, <span class="string">"and"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>};</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;word)</span><br><span class="line"><span class="comment">//只统计不在set中的</span></span><br><span class="line"><span class="keyword">if</span>(exclude.find(word)==exclude.end())</span><br><span class="line">++word_count[word];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; w:word_count)</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;w.first&lt;&lt;<span class="string">" occurs "</span>&lt;&lt;w.second&lt;&lt;((w.second&gt;<span class="number">1</span>?<span class="string">" times"</span>:<span class="string">" time"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>与其他容器类似,set也是模板.为了定义一个set,必须指定其元素类型.<br><code>find()</code>调用返回一个迭代器.如果给定关键字在set中,迭代器指向该关键字.否则,返回尾后迭代器.  </p>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p><code>pair</code>是一个标准库类型,定义在头文件<code>utility</code>中.<br>一个<code>pair</code>,保存两个数据成员.类似容器,<code>pair</code>是一个用来生成特定类型的模板.当创建一个<code>pair</code>时,必须提供给它两个类型名,pair的数据成员将具有对应的类型.两个类型要求不同:  </p>
<ul>
<li><code>pair&lt;string, string&gt; anon;</code>保存两个string </li>
<li><code>pair&lt;string, size_t&gt; word_count;</code>保存一个string和一个size_t</li>
<li><code>pair&lt;string, vector&lt;int&gt;&gt; line;</code>保存一个string和<code>vector&lt;int&gt;</code>     </li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>cpp-智能指针</title>
    <url>/2022/02/04/cpp-zhi-neng-zhi-zhen/</url>
    <content><![CDATA[<p>动态对象的正确释放是编程中容易出错的地方，为了更安全地使用动态对象，标志库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的只能指针可以确保啊自动释放它。<br>智能指针的行为类似常规指针，重要区别在于它负责自动释放所指向的对象。</p>
<ul>
<li><code>shared_ptr</code>允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>独占所指向的对象</li>
<li><code>weak_ptr</code>是一个伴随类，是一种弱引用，指向<code>shared_ptr</code>所管理的对象</li>
<li>这三种类型都定义在<code>memory</code>头文件中<a id="more"></a>

</li>
</ul>
<h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>智能指针也是模板。当创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;<span class="comment">//可以指向string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; p2;<span class="comment">//可以指向元素类型是int的链表</span></span><br></pre></td></tr></tbody></table></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>cpp模板</title>
    <url>/2021/02/18/cpp-mo-ban/</url>
    <content><![CDATA[<p>模板类似于一个宏</p>
<a id="more"></a><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>C++虚表</title>
    <url>/2020/11/01/cpp-xu-biao/</url>
    <content><![CDATA[<h2 id="虚表的具体细节"><a href="#虚表的具体细节" class="headerlink" title="虚表的具体细节"></a>虚表的具体细节</h2><ul>
<li>虚表是cpp实现多态的一个方式，是编译器的具体实现，cpp标准并未规定该如何实现</li>
<li>虚表的作用是，对于虚函数来说，可以使得通过父类调用子类的特定方法，而不是父类的方法，可以做到灵活，或者说是一种多态<a id="more"></a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>en-opengl</title>
    <url>/2022/02/04/en-opengl/</url>
    <content><![CDATA[<h1 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h1><p>OpenGL是一套标准，它定义了怎么使用显卡的API，Nvidia发行   </p>
<ul>
<li>跨平台</li>
<li>简单</li>
<li>让我们可以更好得使用显卡，得到更好的画面<br>shader是运行在GPU上的代码  <a id="more"></a>

</li>
</ul>
<h1 id="Setup-OpenGL-and-Create-a-Window-in-C"><a href="#Setup-OpenGL-and-Create-a-Window-in-C" class="headerlink" title="Setup OpenGL and Create a Window in C++"></a>Setup OpenGL and Create a Window in C++</h1><p>跨平台<br>但创建窗口是很依赖平台的，因此我们要使用一个三方库来为我们屏蔽平台之间的区别，即另一个抽象，这里我们用GLFW，因为它简单轻量<br>首先从<a href="https:://www.glfw.org">glfw</a>下载二进制包</p>
<ul>
<li>把头文件和库复制到<code>&amp;(SolutiionDir)Dependencies</code>下</li>
<li>在设置的常规里包含额外头文件路径</li>
<li>在设置的链接器里包含头文件路径</li>
<li>链接器部分包含静态库文件夹，以及在输入文件里包含静态库文件</li>
<li>在预处理器定定义里包含某些预定义宏</li>
</ul>
<h1 id="Using-Modern-OpenGL-in-C"><a href="#Using-Modern-OpenGL-in-C" class="headerlink" title="Using Modern OpenGL in C++"></a>Using Modern OpenGL in C++</h1><h1 id="Vertex-Buffers-and-Draw-a-Triangle"><a href="#Vertex-Buffers-and-Draw-a-Triangle" class="headerlink" title="Vertex Buffers and Draw a Triangle"></a>Vertex Buffers and Draw a Triangle</h1><p>使用现代OpenGL需要创建一些Buffer和自己的shader<br>Vertex Buffer是一个Buffer，在GPU显存里的内存<br>通过<code>void glGenBuffers(int nums, int* bufferId);</code>来生成一个buffer，把这个buffer的id存在bufferId里，这个id是一个无符号整数</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>C++语法复习</title>
    <url>/2020/12/11/cpp-yu-fa-fu-xi/</url>
    <content><![CDATA[<h3 id="Primer-C-review"><a href="#Primer-C-review" class="headerlink" title="Primer C++ review"></a>Primer C++ review</h3><h3 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><ul>
<li>类的三个用户分别是：类的实现者，类的普通用户和类的继承者(派生类):<br>　　1 、类的实现者：类的设计者，拥有最大的权限，可以访问类中任何权限的成员，主要负责编写类的成员和友元的代码。可以访问类中的公有部分（public），保护部分（protect)和(private)私有部分。<br>　　2、类的普通用户：就是使用类的对象，这部分用户只能访问类的接口（也就是公用部分public)。<br>　　3、类的继承者：就是派生类。派生类能访问基类中的公有部分和受保护的部分，普通用户不能访问受保护的成员。  </li>
<li>基类应该将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义自身的版本，此时基类就将这些函数声明为<strong>虚函数</strong>。<a id="more"></a></li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上<code>virtual</code>关键字,但也可以不写这个关键字，一旦某个函数被声明成虚函数，则在所有派生类中它是虚函数。</li>
<li>在函数声明的分号前面可以使用<code>override</code>关键字来显式覆盖虚函数，如果这个函数因为参数错误未能覆盖相应虚函数，编译器会报错，这是一个帮助程序员排bug的关键字。</li>
<li>只有虚函数才能使用<code>override</code>关键字，普通成员函数不可以使用，否则会报错。</li>
<li><code>final</code>关键字同理只能被虚函数使用，并且如果加了这个关键字，后面的派生类就不可以再覆盖这个虚函数了。</li>
<li>虚函数可以实现动态绑定，但是需要通过引用或者指针调用，否则通过传值调用，类型转换后就不能动态绑定。并且只有继承访问说明符是<code>public</code>时才可以把派生类的对象绑定到基类对象的引用或者指针上。</li>
<li>继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不执行任何实际操作。</li>
<li>派生类可以继承其基类的成员，但是遇到虚函数的时候，派生类应该对其重新定义，即需要提供自己的新定义覆盖(<code>override</code>)从基类继承来的旧定义。</li>
<li>但是也可以不提供自己的定义，从而可以使用基类的定义。</li>
<li>派生类覆盖基类的虚函数时，函数签名应该保持一致，但是有一个例外，当虚函数的返回值是基类的引用或者指针时，派生类的覆盖定义可以把这个引用或者指针的类型改为派生类的类型的指针或者引用，但是前提是派生类到基类的转换是可访问的，即是公有继承。</li>
</ul>
<p>对于纯虚函数:</p>
<ul>
<li>任何构造函数之外的非静态函数，都可以是虚函数，关键字<code>virtual</code>只能出现在类的内部声明语句之前，不能用于类外部的函数定义，如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</li>
<li>成员函数如果没有被声明成虚函数，则其解析过程发生在编译时而非运行时。</li>
<li>虚函数也有<strong>默认实参</strong>，并且如果某次调用使用了默认实参，该实参值由本次调用的<strong>静态类型决定</strong>，即如果通过基类的引用调用一个派生类的虚函数，此时使用的还是基类的默认实参。</li>
<li>有时我们需要<strong>回避虚函数</strong>，即强行调用某个类的某个特定虚函数，此时需要使用作用域描述符调用: baseP-&gt;base::function(); 一般需要回避虚函数的场景是：通过派生类的虚函数调用基类的虚函数，基类的虚函数此时进行一些所有类都需要的工作，派生类再做一些额外的工作。</li>
<li><strong>纯虚函数</strong>：纯虚函数的目的是在于提出一个所有类都应该有的接口，但是基类本身并没有这个接口的具体实现，必须由派生类来实现这个接口。</li>
<li>纯虚函数的声明方式是在分号前加一个<code>=0</code>。</li>
<li>含有纯虚函数的类叫做抽象基类，抽象基类不能实例化，只能有引用和指针，此时他们指向的实际上是它的派生类的对象。</li>
<li>派生类可以把基类中的虚函数定义为纯虚函数（吗？）</li>
<li><strong>基类的析造函数应该是虚的</strong>：当一个基类的指针指向一个派生类时，如果析构函数不是虚的，此时调用析构函数会调用基类的，大多数情况下这不是所期望的。</li>
<li>构造函数绝对不能是虚函数，这是不被支持的错误语法。因为<code>A virtual call is a mechanism to get work done given partial information. In particular, "virtual" allows us to call a function knowing only an interfaces and not the exact type of the object. To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a "call to a constructor" cannot be virtual.</code></li>
</ul>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul>
<li>不管是公有继承还是私有继承，派生类中都有基类中的全部成员。</li>
<li>公有继承的派生类可以在使用基类指针或者基类引用的地方使用。</li>
<li>基类不能隐式向派生类转换。但是可以通过派生类的构造函数隐式转换，此时和普通的转换一致。</li>
<li>并且需要注意的是，即使存在一个基类的指针指向派生类，也不能把这个指针赋值给派生类的一个指针。因为编译器不能在编译时确定基类指针的动态类型。</li>
<li>但是如果能够确定某个基类向派生类的转换是安全的，则可以使用<code>static_cast</code>来强制覆盖编译器的检查工作。</li>
<li>如果基类中有一个或者多个虚函数，可以使用<code>dynamic_cast</code>请求一个类型转换，该转换的安全检查在运行时执行。????????</li>
</ul>
<h5 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h5><ul>
<li>派生类的默认构造函数会调用基类的默认构造函数。</li>
<li>派生类可以自定义构造函数，在构造函数的冒号后面调用基类的相应构造函数，需要给基类的构造函数传相应参数，此时会首先初始化基类，再按照声明顺序构造派生类的成员，这与构造函数的初始化顺序无关。</li>
<li>虽然可以在派生类中初始化基类的公有成员和受保护成员，但是这是不好的行为，应该使用基类的接口：构造函数，初始化基类。</li>
<li>派生类只能调用直接基类的构造函数，不能调用间接基类的构造函数，构造过程通过深度优先构造。</li>
</ul>
<h5 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h5><ul>
<li>在类名后面加一个<code>final</code>: <code>class A final{};</code> <code>class B final: public A{};</code></li>
</ul>
<h5 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h5><ul>
<li>静态类型就是对象的声明类型;动态类型就是对象所指向的内存所代表的实际类型。</li>
<li>只有指针和引用的动态类型和静态类型会不同，其他的对象的两个类型是一致的。</li>
</ul>
<h5 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h5><ul>
<li>派生类可以继承定义在基类中的成员，但是不一定可以访问它们。派生类可以访问基类的公有成员，不能访问私有成员，<code>protected</code>成员是为了让派生类可以访问，而派生类的用户和其他用户不能访问。</li>
<li>继承访问说明符的作用是控制派生类或者派生类的用户访问基类成员的访问权限：公有继承的派生类，它的用户可以按照通常的方式访问基类的成员；私有继承的派生类，它的用户不能访问基类的全部成员，即对于派生类的用户来说，基类全部成员是<code>private</code>的；而受保护的派生类，基类的公有成员对于它来说是受保护的。</li>
<li>继承访问说明符对派生类向基类的转换也有影响<ul>
<li>对于普通用户代码来说，只有公有继承才可使用此转换，私有和受保护的继承不可转换。</li>
<li>对于派生类的成员和友元来说，三个类型的继承都可以使用类型转换。</li>
<li>对于派生类的派生类来说，它的友元和成员函数可以使用公有的继承和受保护的继承转换，但是不可以转换私有的。</li>
</ul>
</li>
</ul>
<h5 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h5><ul>
<li>友元不能传递，也不能继承: 基类的友元访问派生类新的成员没有特殊性，但是可以访问基类的部分，即基类的友元不是派生类的友元，但是此友元可以访问派生类中对应的基类部分。派生类没有继承基类的友元。而友元的派生类仍然是友元，但是新定义的函数以及重写的虚函数不是友元。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>readnotes</tag>
      </tags>
  </entry>
  <entry>
    <title>git command</title>
    <url>/2020/07/09/git-command/</url>
    <content><![CDATA[<h2 id="git常用命令以及与github的结合使用"><a href="#git常用命令以及与github的结合使用" class="headerlink" title="git常用命令以及与github的结合使用"></a>git常用命令以及与github的结合使用</h2><h3 id="git中的四个区域"><a href="#git中的四个区域" class="headerlink" title="git中的四个区域"></a>git中的四个区域</h3><ul>
<li><p>workspace：写和修改代码的地方</p>
</li>
<li><p>index/stage：暂存区，git add [file name]把修改从workspace提交到暂存区</p>
</li>
<li><p>local repository：本地仓库，git commit -m [message] 把修改从暂存区提交到本地仓库</p>
</li>
<li><p>remote ：远程仓库，git push 把修改从本地仓库推送到远程仓库<br><img src="/images/loading.gif" data-original="https://i.bmp.ovh/imgs/2019/07/c49a713c776e6967.png" alt="git区域关系"></p>
<a id="more"></a>
</li>
<li><p>git pull 把远程仓库最新的更改拉取到本地</p>
</li>
<li><p>git add . 把所有本地改动提交到暂存区</p>
</li>
<li><p>git commit -m [message] 把修改从暂存区提交到本地仓库</p>
</li>
<li><p>git push 把修改从本地仓库推送到远程仓库</p>
</li>
<li><p>git里有三个东西:origin master origin/master</p>
<ul>
<li>master是一个本地分支</li>
<li>origin/master是远程分支,是名为origin的远程分支,里面有个本地master的副本,也叫master</li>
<li><code>git push origin master</code>是<code>git push  &lt;REMOTENAME&gt; &lt;BRANCHNAME&gt;</code>的运用,指把本地内容推送到origin(远端)的master分支下,命令里的master指远端的master分支.</li>
<li>名字不一定一定是origin也可以是其他名字:origin1 github gitlab等,master也一样.</li>
</ul>
</li>
<li><p><code>git fetch origin master</code>指从远端origin拉取master分支,此时会会产生一个本地节点副本origin/master,<code>git merge origin/master</code>可以合并这个远端到本地,<code>git push origin master</code>可以把合并后的本地内容推送到远端.</p>
</li>
<li><p><code>git push --set-upstream origin &lt;branchname&gt;</code>,在远端建立分支并把本地分支推送过去.</p>
</li>
</ul>
<p>github从本地推一个新的仓库到远端:  </p>
<ol>
<li><p>在远端新建一个仓库,不要生成readme  </p>
</li>
<li><p>在本地生成rsa公钥和私钥,把公钥手动添加到远端仓库设置里(如果已经设置了可以跳过这一步).    </p>
<figure class="highlight autohotkey"><table><tbody><tr><td class="code"><pre><span class="line">ssh是一种协议,有不同的具体实现.  </span><br><span class="line"><span class="title">其中一种实现非对称密钥,在client本地生成rsa公钥和私钥,手动把公钥保存在服务器:</span>这样可以让服务器验证client的身份,具体方法为,服务器产生一个随机数,通过公钥加密,发送给client,client通过私钥解密随机数,然后和sessionkey一起通过md5加密,发送给服务器,服务器也通过md5加密原先的随机数和sessionkey,验证client发来的两个md5签名是否相同.  </span><br><span class="line">client的rsa密钥保存在`~/.ssh/`下,`id_rsa`保存私钥,`id_rsa.pub`保存公钥,`know_hosts`保存已验证的服务器(实际上client也需要验证服务器的身份以防止中间人攻击).  </span><br><span class="line">`ssh-keygen -t rsa -C <span class="string">"your@email"</span>`命令生成新的rsa公钥私钥,期间有个passphrase,即设置一个密码,是可选的,可以enter直接跳过.      </span><br><span class="line">如果忘记密码了,只有重新生成了.</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>在本地仓库<code>git remote add origin git@github.com:name/reponame.git</code>添加远程索引.如果显示错误:fatal: remote origin already exists.则说明本地仓库已经设置了远端origin的地址,使用<code>git remove remote origin</code>删除原来的设置.   </p>
</li>
<li><p><code>git push -u origin master</code>把本地master推送到远端.    </p>
</li>
<li><p>打标签</p>
<h2 id="git的分支"><a href="#git的分支" class="headerlink" title="git的分支"></a>git的分支</h2><p>git中有三种特殊的对象：<code>blob</code>,<code>tree</code>,<code>commit object</code>。他们之间的关系很密切：</p>
</li>
</ol>
<ul>
<li><code>blob</code>对象是文件的快照，是最根本的数据</li>
<li><code>tree</code>对象是一个树结构，记录着目录结构和<code>blob</code>对象索引</li>
<li><code>commit object</code>包含一个指向暂存内容快照的指针（即指向一个<code>tree</code>对象的指针）。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。</li>
</ul>
<p>git的分支，其实本质上仅仅是指向提交对象的可变指针。Git的默认分支名字是master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。它会在每次的提交操作中自动向<br>前移动。<br>git 的 “master” 分支并不是一个特殊分支。它就跟其它分支完全没有区别。之所以几乎每一个仓库都<br>有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。   </p>
<h3 id="git-分支的创建"><a href="#git-分支的创建" class="headerlink" title="git 分支的创建"></a>git 分支的创建</h3><p>git分支的创建只是为你创建了一个可以移动的新的指针，比如创建一个test分支：<code>git branch test</code><br>这会在当前所在的提交对象上创建一个指针。<br>在不同的分支上提交，会产生分叉<br><img src="/images/loading.gif" data-original="https://i.bmp.ovh/imgs/2021/03/a5ff0c16c7d518d7.png" alt="在两个分支上分别提交会产生分叉"><br>你可以简单地使用<code>git log</code>命令查看分叉历史。运行<code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。  </p>
<h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>使用<code>git checkout test</code>切换到test分支上（当创建了新分支时，head并不会自动指向新分支）<br>注意：支切换会改变你工作目录中的文件在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。这就是为什么经常会报错。<br><code>git checkout -b test2</code>是两个命令的组合：<code>git branch test2</code> <code>git checkout test2</code>即这个命令创建了一个分支，并切换到这个分支。     </p>
<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p><code>git merge branchname</code>把branchname分支合并到当前head指向的分支。<br>如果将要合并的分支（branchname）是当前分支的直接下游，则这种合并叫fast-forward，意思是这个合并只是单纯的把当前分支的指针往前移动，到branchname一样的地方。<br>合并之后可以把临时分支删除了<code>git branch -d tmpbranch</code>,只会删除分支指针，并不会删除blob对象<br>三方合并：两个分支合并到同一个分支（把branchname合并到当前分支），如果他们是分叉的（一个不是另一个的祖先），那么git会找到最优的祖先，进行一个三方合并（把祖先作为参照，然后把改动的地方合并进来），合并完成后，git会自动产生一个提交对象，并把两个分支都向前移动一位指向它。<br>如果两个分支相对于祖先来说，都在同一个文件的同一个位置进行了修改，git就不能自动合并，会产生冲突，此时应该手动解决冲突。  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>IOmodels</title>
    <url>/2021/02/06/int-iomodels/</url>
    <content><![CDATA[<h2 id="I-O-models-in-unix-network-programming"><a href="#I-O-models-in-unix-network-programming" class="headerlink" title="I/O models in unix network programming"></a>I/O models in unix network programming</h2><p>通过<a href="https://mathcs.clarku.edu/~jbreecher/cs280/UNIX%20Network%20Programming(Volume1,3rd).pdf" target="_blank" rel="noopener">&lt;UNIX Network Programming(Volume1,3rd)&gt;</a> 学习unix下的io模型<br>there are  five I/O models that are available to us under Unix:</p>
<ul>
<li>blocking I/O</li>
<li>nonblocking I/O</li>
<li>I/O multiplexing (select and poll)</li>
<li>signal driven I/O (SIGIO)</li>
<li>asynchronous I/O (the POSIX aio_functions)<a id="more"></a>
As we show in all the examples in this section, there are normally two distinct phases for<br>an input operation:</li>
</ul>
<ol>
<li>Waiting for the data to be ready</li>
<li>Copying the data from the kernel to the process<br>For an input operation on a socket, the first step normally involves waiting for data to<br>arrive on the network. When the packet arrives, it is copied into a buffer within the kernel.<br>The second step is copying this data from the kernel’s buffer into our application buffer.<br>在unix下有五种I/O模型:</li>
</ol>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>多路复用I/O</li>
<li>信号驱动I/O</li>
<li>异步I/O<br>所有的例子中,输入有两个阶段的操作:</li>
</ul>
<ol>
<li>等待数据就位</li>
<li>从内核中copy数据到进程中</li>
<li></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2021/02/18/int-zong-jie/</url>
    <content><![CDATA[<p>待看：粘包 epoll怎么去检查文件描述符 epoll的回调函数 特例化</p>
<h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h2 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h2><p>当要合并别人的代码调试:git pull ,git merge.  </p>
<h2 id="未使用的静态库会被链接吗？"><a href="#未使用的静态库会被链接吗？" class="headerlink" title="未使用的静态库会被链接吗？"></a>未使用的静态库会被链接吗？</h2><p>默认不会  </p>
<h2 id="怎么阻止类被继承"><a href="#怎么阻止类被继承" class="headerlink" title="怎么阻止类被继承"></a>怎么阻止类被继承</h2><p>用final关键字<br>把构造函数设为私有的，并通过友元构造本对象，因为友元不能被继承，同时使用虚继承。  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BASE</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                BASE(){}</span><br><span class="line">                <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span>    <span class="comment">//设class C为class BASE的友元</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> <span class="keyword">virtual</span> BASE</span><br><span class="line">{</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> C</span><br><span class="line">{</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        C c;</span><br><span class="line">        <span class="comment">//D d;   不可以实例化对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为什么class C要虚拟继承class BASE 而不是直接继承呢？<br><img src="/images/loading.gif" data-original="https://ftp.bmp.ovh/imgs/2021/03/39ec1e8d954d2a79.png" alt="虚继承"></p>
<a id="more"></a>

<h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><p>信号（已解决）<br>管道：<br>共享内存:<br>消息队列：<br>socket：<br>信号量：<br>竞争条件？互斥量？条件变量？</p>
<h2 id="分布式锁？？"><a href="#分布式锁？？" class="headerlink" title="分布式锁？？"></a>分布式锁？？</h2><h2 id="python1-100相加？？"><a href="#python1-100相加？？" class="headerlink" title="python1 -100相加？？"></a>python1 -100相加？？</h2><h2 id="计算型多进程-io型多线程"><a href="#计算型多进程-io型多线程" class="headerlink" title="计算型多进程 io型多线程"></a>计算型多进程 io型多线程</h2><h2 id="进程挂掉了怎么排错？？？？？"><a href="#进程挂掉了怎么排错？？？？？" class="headerlink" title="进程挂掉了怎么排错？？？？？"></a>进程挂掉了怎么排错？？？？？</h2><h2 id="看哪个进程使用内存最大"><a href="#看哪个进程使用内存最大" class="headerlink" title="看哪个进程使用内存最大"></a>看哪个进程使用内存最大</h2><h2 id="看最近7天未使用文件"><a href="#看最近7天未使用文件" class="headerlink" title="看最近7天未使用文件"></a>看最近7天未使用文件</h2><h1 id="momenta"><a href="#momenta" class="headerlink" title="momenta"></a>momenta</h1><h2 id="静态库的链接顺序有影响吗？"><a href="#静态库的链接顺序有影响吗？" class="headerlink" title="静态库的链接顺序有影响吗？"></a>静态库的链接顺序有影响吗？</h2><p>有:<code>gcc main.o -lz print.o -o main</code>命令把<code>main.o z print.o</code>连接起来，符号表的决议是从做到右搜索，过程为：先解决<code>main.o</code>的符号决议，先搜索<code>z</code>再搜索<code>print.o</code>，然后决议<code>z</code>，只搜索z右边的<code>print.o</code>，然后决议<code>print.o</code>，由于右边没有文件了，如果<code>print.o</code>中有在<code>z</code>中未决议的符号，由于不会再搜索<code>z</code>，所以得不到决议，就会产生符号为定义的问题，但是如果<code>print.o</code>在<code>main.o</code>中有依赖，不会出现问题，只在<code>-l</code>中的顺序有影响。 </p>
<h1 id="创新奇智"><a href="#创新奇智" class="headerlink" title="创新奇智"></a>创新奇智</h1><h2 id="浮点数比较大小"><a href="#浮点数比较大小" class="headerlink" title="浮点数比较大小"></a>浮点数比较大小</h2><p>浮点数不能直接用<code>==</code>比大小，就算是输出的时候发现数值相等也不一定相等。<br>两个方面：</p>
<ul>
<li>首先是实数转换成计算机浮点数存储的时候是不能精确存储的，会有精度损失。</li>
<li>其次是输出的时候，有时有默认输出位数，你看到可能结果是一样的，但实际上是舍入之后的结果，实际上存储的两个浮点数在更高精度上是不一样的。<br>比如<code>0.1+0.2==0.3</code>的结果是false，原因就是0.1的浮点数表示可能不是精确的0.1，加上0.2之后并不会精确为0.3，或者0.3本身存储的精确值也不是0.3，两个方面的不精确导致了不相等。<br>因此要比较两个浮点数的大小或者是否相等，应该定义一个误差值eps：<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-12</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">double</span> delta=x-y;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(delta)&lt;eps)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(delta&gt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h2 id="sizeof大小问题"><a href="#sizeof大小问题" class="headerlink" title="sizeof大小问题"></a>sizeof大小问题</h2><p>这个问题一般比较麻烦的是对于数组的大小计算，如果是未退化的数组，则sizeof得出的是整个数组的大小，而如果是数组退化成指针，则返回一个指针的大小。<br>要退化的情况：</p>
<ul>
<li>数组赋值给一个指针，sizeof(ptr)结果是一个指针的大小</li>
<li>把数组作为参数传给一个函数，就算这个函数的形参列表是以数组的形式接收形参，也会</li>
</ul>
<h1 id="商汤"><a href="#商汤" class="headerlink" title="商汤"></a>商汤</h1><h2 id="C-中空类或者空结构体大小是多少，能取地址吗？"><a href="#C-中空类或者空结构体大小是多少，能取地址吗？" class="headerlink" title="C++中空类或者空结构体大小是多少，能取地址吗？"></a>C++中空类或者空结构体大小是多少，能取地址吗？</h2><p>C++为了能够让每一个类的实例有独特性，取地址的时候都不一样，则在空类中插了一个字节，因此空类或者空结构体大小是1字节，能取地址<br>而当他们被继承后，如果子类有自己的实例成员，则成员从地址偏移0处开始存，即：不会继承父类的那个被插入的字节，实现了0 overhead<br>而如果有虚函数，因为虚指针的存在，因此没有必要再插入这一个字节   </p>
<blockquote>
<p>Why is the size of an empty class not zero?<br>To ensure that the addresses of two different objects will be different. For the same reason, “new” always returns pointers to distinct objects. Consider:</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> {</span> };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Empty a, b;</span><br><span class="line"><span class="keyword">if</span> (&amp;a == &amp;b) <span class="built_in">cout</span> &lt;&lt; <span class="string">"impossible: report error to compiler supplier"</span>;</span><br><span class="line"></span><br><span class="line">Empty* p1 = <span class="keyword">new</span> Empty;</span><br><span class="line">Empty* p2 = <span class="keyword">new</span> Empty;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"impossible: report error to compiler supplier"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>There is an interesting rule that says that an empty base class need not be represented by a separate byte:</p>
</blockquote>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> :</span> Empty {</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X* p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">void</span>* p1 = p;</span><br><span class="line"><span class="keyword">void</span>* p2 = &amp;p-&gt;a;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) <span class="built_in">cout</span> &lt;&lt; <span class="string">"nice: good optimizer"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>This optimization is safe and can be most useful. It allows a programmer to use empty classes to represent very simple concepts without overhead. Some current compilers provide this “empty base class optimization”.<br>C语言空结构体大小是0  </p>
</blockquote>
<h2 id="unique-ptr不可以赋值给另一个unique-ptr，但是可以通过std-move-赋值"><a href="#unique-ptr不可以赋值给另一个unique-ptr，但是可以通过std-move-赋值" class="headerlink" title="unique_ptr不可以赋值给另一个unique_ptr，但是可以通过std::move()赋值"></a>unique_ptr不可以赋值给另一个unique_ptr，但是可以通过std::move()赋值</h2><h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h2 id="进程拿到锁之后崩溃了"><a href="#进程拿到锁之后崩溃了" class="headerlink" title="进程拿到锁之后崩溃了"></a>进程拿到锁之后崩溃了</h2><ol>
<li>注册信号量处理函数，当崩溃时先释放锁再崩溃。  </li>
<li>设置超时机制，如果超时则强制释放锁。</li>
<li>进程重启之后释放锁。<h2 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h2>多态的实现：在类的起始位置加一个虚指针，指向这个子类的虚表，里面有子类的虚函数，调用它。  <h2 id="epoll和select的区别"><a href="#epoll和select的区别" class="headerlink" title="epoll和select的区别"></a>epoll和select的区别</h2>select的函数原型<code>int select(int maxfdp1, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timeval* timeout);</code><br><code>returns: positive count of ready descriptors, 0 on timeout, -1 on error</code> 返回0表示超时并没有文件描述符就绪，返回-1表示出错，返回正数表示可用的文件描述符数量。<br>参数：</li>
<li>最后一个参数是一个时间结构体，告诉操作系统最长等待多少时间，里面标明了等待的秒数和微秒数：<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>{</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;<span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">//microseconds</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
这个时间会产生三种可能性：  </li>
</ol>
<ul>
<li>永久等待：传入NULL指针，表示只有当有文件描述符就绪时才返回</li>
<li>等待一定时间：最多等待timeval结构体里标明的时间返回</li>
<li>检查文件描述符后马上返回，也叫做轮询（polling）：把timeval里的时间全设为0</li>
</ul>
<p>前两种的等待一般会打断，如果进程得到一个信号，并从信号处理句柄处返回时。<br>（信号？？？）<br>有的linux发行版的实现从不会重启select，而有的会，我们应该默认不会，并准备获取一个<code>EINTR</code>error（当我们获得一个信号时）<br>2. 倒数第二个参数<code>fd_set*exceptset</code>表示异常条件的描述符，目前支持两个<br>(1)某个套接字的带外数据到达<br>(2)不讨论<br>3. 读集合和写集合参数<br><code>fd_set</code>是一个整数数组，里面的第n位标识了描述符为n的描述符，具体实现细节应用程序不必知道，而用四个宏来操作：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set*fdset)</span></span>;<span class="comment">//把fdset初始化，把所有位置零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set*fdset)</span></span>;<span class="comment">//把fd代表的位置1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set*fdset)</span></span>;<span class="comment">//把fd代表的位清0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set*fdset)</span></span>;<span class="comment">//查看fdset里的fd是否置位</span></span><br></pre></td></tr></tbody></table></figure>
<p>初始化非常重要，一定要<code>FD_ZERO(fd,&amp;fdset)</code><br>如果我们对中间三个参数：读描述符集、写描述符集、异常集中某个不感兴趣，把它设为NULL即可，如果这三个都是空指针，那么就获得一个比<code>sleep</code>更为精确的定时器，因为sleep以秒为精确值而select以微秒为单位。<br>4. <code>int maxfdp1</code>表示待测试的描述符个数，它的值是待测试的描述符的最大值加1，因此它的名字叫max fd plus 1，描述符0到maxfdp1-1都会被测试，之所以不是最大的描述符，是因为表示的是个数而不是最大值，个数从0开始。<br>要用户自己传入最大值是为了效率起见，有了最大值，内核就不必复制不关心的那些描述符了。  </p>
<p><code>select</code>会修改未就绪的描述符的值为0，也就是说，调用<code>select</code>后我们需要通过宏<code>FD_ISSET(fd)</code>来测试所关心的描述符是否就绪，并且如果重新调用<code>select</code>我们需要再次把所关心的描述符置1。<br>经常会犯的两个错误：maxfdp1的值设为最大值，而没有+1；再次调用select时没有把关心的描述符设为1，以为它还是1（有可能已经变成0了）<br>函数的返回值表示就绪的描述符数量，如果同一个描述符既读就绪也写就绪，那么会计算两次；如果返回0表示超时；返回-1表示错误，比如期间进程捕获了一个信号中断。<br>描述符就绪的条件：<br>待写？？？？？？？？？？？？？？<br>select对于大的描述符会有一些问题，一般select允许的的最大描述符是256或者1024，用户可以自定义大小，但是通常太大了会有一些问题。  </p>
<h2 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h2><p>epoll<br>realloc的注意事项<br>引用和指针的区别</p>
<h1 id="三七互娱笔试"><a href="#三七互娱笔试" class="headerlink" title="三七互娱笔试"></a>三七互娱笔试</h1><h2 id="ISO七层协议分别的作用"><a href="#ISO七层协议分别的作用" class="headerlink" title="ISO七层协议分别的作用"></a>ISO七层协议分别的作用</h2><h2 id="二叉树的高度"><a href="#二叉树的高度" class="headerlink" title="二叉树的高度"></a>二叉树的高度</h2><h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><h2 id="通过后序遍历中序遍历得出前序遍历"><a href="#通过后序遍历中序遍历得出前序遍历" class="headerlink" title="通过后序遍历中序遍历得出前序遍历"></a>通过后序遍历中序遍历得出前序遍历</h2><p>##</p>
<h2 id="计算一个32位无符号整数中1的个数"><a href="#计算一个32位无符号整数中1的个数" class="headerlink" title="计算一个32位无符号整数中1的个数"></a>计算一个32位无符号整数中1的个数</h2><ol>
<li>循环：<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_bit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span>  </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(num&amp;<span class="number">1</span>==<span class="number">1</span>)</span><br><span class="line">        cnt++;</span><br><span class="line">        num=num&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>swar算法<br><a href="https://zhuanlan.zhihu.com/p/165968167" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/165968167</a>  <figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swar</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    num=(num&amp;<span class="number">0x55555555</span>)+((num&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0x55555555</span>);</span><br><span class="line">    num=(num&amp;<span class="number">0x33333333</span>)+((num&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x33333333</span>);</span><br><span class="line">    num=(num&amp;<span class="number">0x0f0f0f0f</span>)+((num&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    num=(num*<span class="number">0x01010101</span>)&gt;&gt;<span class="number">24</span>;</span><br><span class="line">    <span class="comment">// num=(num&amp;0x00ff00ff)+((num&gt;&gt;8)&amp;0x00ff00ff);</span></span><br><span class="line">    <span class="comment">// num=num&amp;0x0000ffff+((num&gt;&gt;16)&amp;0x0000ffff);</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="开方算法"><a href="#开方算法" class="headerlink" title="开方算法"></a>开方算法</h2></li>
<li>二分法<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">b_sqrt</span><span class="params">(<span class="keyword">double</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>||num==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">double</span> low,high,mid;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        low=<span class="number">1</span>;</span><br><span class="line">        high=num;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        low=num;</span><br><span class="line">        high=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(high-low&gt;eps)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(mid*mid&gt;num)</span><br><span class="line">        {</span><br><span class="line">            high=mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            low=mid;</span><br><span class="line">        }</span><br><span class="line">            mid=(high+low)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>牛顿迭代法</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a href="https://www.cnblogs.com/ywliao/articles/8116622.html" target="_blank" rel="noopener">https://www.cnblogs.com/ywliao/articles/8116622.html</a><br><a href="https://blog.csdn.net/csdn1126274345/article/details/82557966动态链接中的名字冲突问题" target="_blank" rel="noopener">https://blog.csdn.net/csdn1126274345/article/details/82557966动态链接中的名字冲突问题</a> </p>
<h2 id="什么是进程什么是线程？"><a href="#什么是进程什么是线程？" class="headerlink" title="什么是进程什么是线程？"></a>什么是进程什么是线程？</h2><p>进程是资源分配的基本单位。<br>线程是资源调度的基本单位。<br>一个进程包含一个或者多个线程。cpu上运行的是一个个线程。<br>进程拥有自己的地址空间、栈、堆、寄存器等。<br>线程拥有线程栈、寄存器、程序计数器等，一个进程中的线程共享进程的地址空间、全局变量、静态变量、堆等。  </p>
<!-- more -->
<h2 id="进程间通信的方式？"><a href="#进程间通信的方式？" class="headerlink" title="进程间通信的方式？"></a>进程间通信的方式？</h2><p>管道、命名管道：在<br>信号：<br>信号量：一个信号量代表了一种有限的资源，<br>共享内存：可以通过页表映射完成<br>消息队列：<br>socket：<br>客户端：<code>socket()</code> <code>connect()</code><br>服务器端：  </p>
<h2 id="线程间通信的方式？"><a href="#线程间通信的方式？" class="headerlink" title="线程间通信的方式？"></a>线程间通信的方式？</h2><ol>
<li>锁：</li>
</ol>
<ul>
<li>互斥锁</li>
<li>自旋锁</li>
<li>读写锁</li>
<li>条件变量</li>
</ul>
<ol start="2">
<li>信号  </li>
<li>信号量  </li>
<li>屏障？？？？？？？？ </li>
</ol>
<p>线程间通信的目的主要是为了线程同步，所以线程中没有像进程中用于数据交换的通信机制。  </p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>死锁是两个或者多个进程在竞争资源时产生的一种阻塞现象。<br>两个或多个进程中，一个进程请求另一个进程所拥有的资源，这种占有和请求的关系形成了一条环，导致这些进程都被阻塞无法推进。  </p>
<h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><p>系统提供的资源不能满足进程的要求。（资源的有限性）<br>进程推进顺序的不合理。  </p>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ol>
<li>请求和保持：进程因未分配到新的资源而受阻，但对已占有的资源又不释放。  </li>
<li>互斥：进程占有资源后排斥其他进程使用该资源。</li>
<li>不可剥夺：正在是使用的资源不可剥夺，只能由占有资源的进程自动释放，不能被其他进程强行占用。</li>
<li>环路等待：存在进程的循环等待链，前一进程占有的资源正是后一进程所请求的资源，结果就形成了循环等待的僵持局面。 </li>
</ol>
<h3 id="死锁的解决"><a href="#死锁的解决" class="headerlink" title="死锁的解决"></a>死锁的解决</h3><p>预防死锁、发现死锁、解除死锁，具体来说：  </p>
<ul>
<li>打破互斥条件：将独占性资源改造成虚拟资源，但是大部分资源不可改造</li>
<li>打破不可抢占条件：当一进程占有一独有资源后又申请一独占资源而无法被满足则释放原独占的资源</li>
<li>打破请求和保持条件：采用资源预先分配策略，即进程运行前就申请全部资源，不能被满足就不运行。优点是易于实现，缺点是资源利用率不高</li>
<li>打破环路等待条件：实现资源有序分配策略，将每种资源按序排列，进程只能按序递增申请资源，按序递减释放资源，只有低编号的资源得到满足才能申请高编号的资源，高编号资源被释放才能释放低编号资源，这样就打破了循环等待链。</li>
</ul>
<p>相关算法：</p>
<ul>
<li>有序资源分配算法：编号。</li>
<li>银行家算法：计数、替换。  </li>
</ul>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p>Socket通信的数据传输方式，常用的有两种：</p>
<ol>
<li>SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。</li>
<li>SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。</li>
</ol>
<h3 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h3><p><code>#include&lt;sys/socket.h&gt;</code><br><code>int socket(int af, int type, int protocol);</code><br><code>af</code>是一个地址描述符，仅支持<code>AF_INET</code>格式，也就是<code>ARPA Internet</code>地址格式<br><code>type</code>指定socket类型，支持的类型有：<code>SOCKET_STREAM</code>(TCP协议)、<code>SOCKET_DGRAM</code>(UDP协议)<br><code>protocol</code>指定协议，如果调用者不想指定，则传入0。<br>若无错误发生，<code>socket()</code>返回引用新套接口的描述字。否则的话，返回<code>INVALID_SOCKET</code>错误，应用程序可通过<code>WSAGetLastError()</code>获取相应错误代码。  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment"> * create an IPv4/TCP socket, not yet bound to any address</span></span><br><span class="line"><span class="comment"> *********************************************************/</span></span><br><span class="line"><span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"socket: %s\n"</span>, strerror(errno));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="socket的绑定"><a href="#socket的绑定" class="headerlink" title="socket的绑定"></a>socket的绑定</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment"> * internet socket address structure, for the remote side</span></span><br><span class="line"><span class="comment"> *********************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"><span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line"><span class="built_in">sin</span>.sin_addr.s_addr = inet_addr(server);</span><br><span class="line"><span class="built_in">sin</span>.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sin</span>.sin_addr.s_addr == INADDR_NONE) {</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"invalid remote IP %s\n"</span>, server);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>创建了一个socket后，把这个socket绑定到相应的ip和端口。  </p>
<h2 id="cpp的四种cast"><a href="#cpp的四种cast" class="headerlink" title="cpp的四种cast"></a>cpp的四种cast</h2><p>有时我们希望显式地将对象强制转换成另一种类型。<br><code>cast-name&lt;type&gt;(expression);</code><br><code>cast-name</code>有<code>static_cast</code> <code>dynamic_cast</code> <code>const_cast</code>和<code>reinterpret_cast</code>  </p>
<h3 id="stacit-cast"><a href="#stacit-cast" class="headerlink" title="stacit_cast"></a><code>stacit_cast</code></h3><p>任何具有明确定义的类型转换，只要不包含底层const（指针本身是const叫做顶层const，指针指向的对象是const叫底层const）都可以使用<code>static_cast</code>。<br>当需要把一个较大的算术类型赋值给较小的类型时，它非常有用。  </p>
<h2 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h2><ol>
<li>申请的内存所在位置<br>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。<br>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。<br>特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：<br><code>new(place_address)type</code><br>place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：<br><code>void* operator new (size_t,void *)</code> //不允许重定义这个版本的operator new<br>这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。  </li>
<li>返回类型安全性<br>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。  </li>
<li>内存分配失败时的返回值<br>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。<br>在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：  </li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *a  = (<span class="keyword">int</span> *)<span class="built_in">malloc</span> ( <span class="keyword">sizeof</span> (<span class="keyword">int</span> ));</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == a)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从C语言走入C++阵营的新手可能会把这个习惯带入C++： </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> == a)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{   </span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：  </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (bad_alloc)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果你想顺便了解下异常基础，可以看<a href="http://www.cnblogs.com/QG-whz/p/5136883.htmlC++" target="_blank" rel="noopener">http://www.cnblogs.com/QG-whz/p/5136883.htmlC++</a> 异常机制分析。<br>4. 是否需要指定内存大小<br>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>{</span>...}</span><br><span class="line">A * ptr = <span class="keyword">new</span> A;</span><br><span class="line">A * ptr = (A *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(A)); <span class="comment">//需要显式指定所需内存大小sizeof(A);</span></span><br></pre></td></tr></tbody></table></figure>
<p>当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。<br>5. 是否调用构造函数/析构函数<br>使用new操作符来分配对象内存时会经历三个步骤：<br>第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。<br>第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。<br>第三部：对象构造完成后，返回一个指向该对象的指针。<br>使用delete操作符来释放对象内存时会经历两个步骤：<br>第一步：调用对象的析构函数。<br>第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。<br>总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：</p>
<p>class A<br>{<br>public:<br>    A() :a(1), b(1.11){}<br>private:<br>    int a;<br>    double b;<br>};<br>int main()<br>{<br>    A * ptr = (A*)malloc(sizeof(A));<br>    return 0;<br>}<br>在return处设置断点，观看ptr所指内存的内容：</p>
<p>可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。</p>
<p>而使用new来分配对象时：</p>
<p>int main()<br>{<br>    A * ptr = new A;<br>}<br>查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：</p>
<ol start="6">
<li>对数组的处理<br>C++提供了new[]与delete[]来专门处理数组类型:</li>
</ol>
<p>A * ptr = new A[10];//分配10个A对象<br>使用new[]分配的内存必须使用delete[]进行释放：</p>
<p>delete [] ptr;<br>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p>
<p>至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p>
<p>int * ptr = (int *) malloc( sizeof(int) );//分配一个10个int元素的数组<br>7. new与malloc是否可以相互调用<br>operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：</p>
<p>void * operator new (sieze_t size)<br>{<br>    if(void * mem = malloc(size)<br>        return mem;<br>    else<br>        throw bad_alloc();<br>}<br>void operator delete(void *mem) noexcept<br>{<br>    free(mem);<br>}<br>8. 是否可以被重载<br>opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：</p>
<p>//这些版本可能抛出异常<br>void * operator new(size_t);<br>void * operator new<a href="size_t"></a>;<br>void * operator delete (void * )noexcept;<br>void * operator delete[](void *0）noexcept;<br>//这些版本承诺不抛出异常<br>void * operator new(size_t ,nothrow_t&amp;) noexcept;<br>void * operator new[](size_t, nothrow_t&amp; );<br>void * operator delete (void *,nothrow_t&amp; )noexcept;<br>void * operator delete[](void *0,nothrow_t&amp; ）noexcept;<br>我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。</p>
<p>而malloc/free并不允许重载。</p>
<ol>
<li>能够直观地重新分配内存<br>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</li>
</ol>
<p>new没有这样直观的配套设施来扩充内存。</p>
<ol start="10">
<li>客户处理内存分配不足<br>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：</li>
</ol>
<p>namespace std<br>{<br>    typedef void (*new_handler)();<br>}<br>指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p>
<p>namespace std<br>{<br>    new_handler set_new_handler(new_handler p ) throw();<br>}<br>set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。</p>
<p>对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p>
<p>总结<br>将上面所述的10点差别整理成表格：</p>
<p>特征    new/delete    malloc/free<br>分配内存的位置    自由存储区    堆<br>内存分配失败返回值    完整类型指针    void*<br>内存分配失败返回值    默认抛出异常    返回NULL<br>分配内存的大小    由编译器根据类型计算得出    必须显式指定字节数<br>处理数组    有处理数组的new版本new[]    需要用户计算数组的大小后进行内存分配<br>已分配内存的扩充    无法直观地处理    使用realloc简单完成<br>是否相互调用    可以，看具体的operator new/delete实现    不可调用new<br>分配内存时内存不足    客户能够指定处理函数或重新制定分配器    无法通过用户代码进行处理<br>函数重载    允许    不允许<br>构造函数与析构函数    调用    不调用<br>malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种</p>
<p>而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用:</p>
<p>当然，malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。</p>
<p>感谢您的耐心阅读。</p>
<p>原文：</p>
<p>id to struct </p>
<p>ps<br>generation = (e-&gt;env_id + (1 &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - 1);//0x000fff 0xfff000<br>    if (generation &lt;= 0)    // Don’t create a negative env_id.<br>        generation = 1 &lt;&lt; ENVGENSHIFT;<br>    e-&gt;env_id = generation | (e - envs);<br>hash<br>  数目小<br>  空间浪费 </p>
<p>STL的实现string等<br>找项目<br>程序员的自我修养—链接、装载与库<br>锁<a href="https://www.jianshu.com/p/5725db8f07dc" target="_blank" rel="noopener">https://www.jianshu.com/p/5725db8f07dc</a><br>linux用户抢占和内核抢占详解(概念, 实现和触发时机)–Linux进程的管理与调度(二十）<a href="https://cloud.tencent.com/developer/article/1368153" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1368153</a><br><a href="https://github.com/gatsbyd/melon" target="_blank" rel="noopener">https://github.com/gatsbyd/melon</a><br>Linux内核同步机制之（四）：spin lock<a href="http://www.wowotech.net/kernel_synchronization/spinlock.html" target="_blank" rel="noopener">http://www.wowotech.net/kernel_synchronization/spinlock.html</a><br>系统调用的三种方式<a href="https://blog.csdn.net/QFFQFF/article/details/76762232" target="_blank" rel="noopener">https://blog.csdn.net/QFFQFF/article/details/76762232</a><br>简单的聊天室实现（上）：通信-SOCKET<a href="https://zhuanlan.zhihu.com/p/24475299" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24475299</a><br>Example: Nonblocking I/O and select() <a href="https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzab6/xnonblock.htm" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_72/rzab6/xnonblock.htm</a><br>MIT 6.828 JOS/XV6 LAB4-partA<a href="https://www.cnblogs.com/bdhmwz/p/5105325.html" target="_blank" rel="noopener">https://www.cnblogs.com/bdhmwz/p/5105325.html</a><br>TLB<br>unordered_map<br>deque<br>迭代器失效</p>
<p>csapp</p>
<p>管道<br>共享内存<br>rpc<br>linux文件系统<br>内核空间是怎么同步的<br>僵尸进程<br>孤儿进程<br>http tcp实现，客户端发送请求，服务器发送应答，三次握手，<br>请求格式：请求行：请求url、请求协议版本、请求方法（get获取页面、put提交数据、head）；<br>请求头：键值对（通信具体细节：close（短连接）、keepalive（长连接）、）；<br>请求数据（body） 空行请求结束<br>服务器收到后:根据url决定；<br>响应：响应行（协议版本、状态码（1xx等待，过程中、2xx成功、3xx几重定向、4xx客户端失败、5xx服务器端失败）、状态描述）；<br>响应头部：键值对、内容长度；<br>响应数据：html、css文件 空行结束<br>短链接：每次tcp三次握手只发生一次请求和响应，然后断开<br>长连接：保持tcp连接<br>一次点击请求多次<br>响应头里可以设置超时时间   KeyAlive<br>多路复用：http2支持，多个请求用一个tcp连接；不管请求的顺序是怎么样，可以随意次序回应<br>url</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>进程间通信IPC</title>
    <url>/2021/02/06/int-jin-cheng-jian-tong-xin-ipc/</url>
    <content><![CDATA[<h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p>通过&lt;Unix Network Program volume 2: Interprocess Communications&gt;学习.  </p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>IPC的意思是进程间通信.传统上这个术语描述的是运行在同一操作系统上的不同进程之间传递信息的方式.这本书也会描述几种同步(synchronization)的形式.因为更新形式的通信比如共享内存,需要某些形式的同步来实现.<br>pipe是最开始广泛被运用的IPC,不仅可以在进程间,也可以在进程和shell间,但是它只能在有共同祖先的进程间起作用(父子之间也行).而命名管道弥补了这个不足.  </p>
<a id="more"></a>
<p>消息队列(message queue)在1980年代首先被使用在System V中,现在在Unix中基本都可以使用这一方式.消息队列可以在一指定的host上不关联进程间使用.<br>Remote Procedure Calls(RPCs,远程过程调用)在1980中期出现.它可以用在服务器和客户端之间,客户端上的一个进程可以调用服务器上的一个函数,以返回结果,这在网络编程中使用.鉴于客户端和服务端可以在同一个主机上,那么RPCs也可以用在进程通信上.<br>Unix提供给的几种形式的synchronization:<br>早期的程序需要某些形式的同步(synchronization)以阻止多进程同时修改同一文件.  </p>
<ul>
<li>Record locking</li>
<li>semaphores (信号量)</li>
<li>mutexes and condition variables 是两种形式的同步,经常被用于在线程之间同步,也可以提供进程间的同步.</li>
<li>read-write locks(读写锁)<h4 id="1-2-进程-线程-和信息共享"><a href="#1-2-进程-线程-和信息共享" class="headerlink" title="1.2 进程,线程, 和信息共享"></a>1.2 进程,线程, 和信息共享</h4>在传统的Unix编程模型中,我们有多个进程跑在系统中,每个进程有自己的地址空间.信息可以在进程间通过多种方式被共享.<br><img src="/images/loading.gif" data-original="https://ftp.bmp.ovh/imgs/2021/02/7539c2400224619f.png" alt="进程间通信方式">  </li>
</ul>
<ol>
<li>左边的两个进程通过文件系统中的一个文件共享信息.为了获取数据,每个进程必须通过内核(read, write, lseek等)获取.某些形式的同步在这个过程中是需要的,因为要防止同时读写产生错误.  </li>
<li>中间的两个进程通过内核共享信息.管道,消息队列和信号量(semaphore)就是这种类型的共享.每个获取共享信息的操作都需要一个系统调用.  </li>
<li>右边的两个进程有一块每个进程都可以引用的共享内存.一旦共享内存在进程之间建立起来,之后获取数据的操作便不需要内核参与.某些形式的同步在这个过程中也是需要的.<br>注意:所有的进程间通信技术都没有限制进程的数量,虽然有时只通过两个进程举例,但是这对多少个进程都是适用的.  <h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5>在一个进程中的所有线程共享全局变量.我们必须关心的是大量线程获取这些全局数据的同步情况.虽然同步并不是一个很显然的IPC形式,却被用在许多形式的IPC中以控制对共享信息的获取.<br>我们将描述进程间的通信以及线程间的通信.  </li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>lua-实现</title>
    <url>/2022/02/04/lua-shi-xian/</url>
    <content><![CDATA[<h2 id="值的内部表示"><a href="#值的内部表示" class="headerlink" title="值的内部表示"></a>值的内部表示</h2><p>Lua是动态类型的语言：类型是与值而不是变量相关。相对应的是静态类型语言，比如C语言，变量需要声明类型，而Python和Lua是动态类型语言，变量的类型是与值相关的，变量只会改变指向的值而不会改变指向的内容。</p>
<a id="more"></a>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>make manual read notes</title>
    <url>/2020/12/11/make/</url>
    <content><![CDATA[<h2 id="make-manual-read-notes"><a href="#make-manual-read-notes" class="headerlink" title="make manual read notes"></a>make manual read notes</h2><p>manual download: <a href="https://www.gnu.org/software/make/manual/make.pdf" target="_blank" rel="noopener">https://www.gnu.org/software/make/manual/make.pdf</a>  </p>
<h3 id="1-Overview-of-make"><a href="#1-Overview-of-make" class="headerlink" title="1 Overview of make"></a>1 Overview of make</h3><p>  make可以自动地决定一个大型项目中的哪些部分需要被重新编译，并且列出重新编译他们的命令(所以make是为了更好地自动编译项目)。</p>
<a id="more"></a>  
<p>  make可以与任何可以使用命令行的编译器使用，因此几乎所有编程语言都可以用make编译。并且make不仅仅限于编程，还可以用它来描述任何需要自动更新的文件的更新方式。<br>  为了可以使用make，需要事先写一个叫做<code>makefile</code>的文件，里面描述了你的程序里的文件的关系以及提供了如何更新这些文件的命令。比如对于一个程序来说，可执行文件是由目标文件构建或者更新的。<br>  一旦写好了一个合适的<code>makefile</code>，每次更改一些源文件之后，只需要在命令行中调用<code>make</code>就可以自动编译你的项目了。</p>
<h3 id="2-An-Introduction-to-Makefiles"><a href="#2-An-Introduction-to-Makefiles" class="headerlink" title="2 An Introduction to Makefiles"></a>2 An Introduction to Makefiles</h3><p>  你需要一个叫做<code>makefile</code>的文件来告诉<code>make</code>应该做什么。大多数情况下<code>makefile</code>告诉<code>make</code>怎么编译和链接一个程序。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>mit6.828-lab2</title>
    <url>/2020/11/30/mit6-828-lab2/</url>
    <content><![CDATA[<h3 id="mit6-828-lab2-memory-management"><a href="#mit6-828-lab2-memory-management" class="headerlink" title="mit6.828-lab2:memory management"></a>mit6.828-lab2:memory management</h3><h4 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h4><p>这次实验，我们要为我们的操作系统写一个内存管理器。   </p>
<p>内存管理器有两个组成部分：</p>
<ol>
<li>第一个组成部分是内核的物理内存分配器，可以让内核分配内存以及释放内存。我们写的这个分配器，以4K为一个操作单元（称作一个页）。我们的任务是管理记录物理内存状态的一个数据结构（引用数、下一个页地址等）。我们还会写一系列与分配和释放物理内存相关的函数。</li>
<li>第二个组成部分是虚拟内存管理组件，它将内核和用户使用的虚拟内存映射到物理内存中。x86的内存管理单元硬件将完成虚拟地址向物理地址的映射，通过一些页表。我们将根据提供的一个特殊布局来修改JOS，从而建立一个内存管理单元的页表系统。  <a id="more"></a>
<h4 id="Part1-Physical-Page-Management"><a href="#Part1-Physical-Page-Management" class="headerlink" title="Part1:Physical Page Management"></a>Part1:Physical Page Management</h4></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>mit6.828-lab1</title>
    <url>/2020/10/21/mit6-828-lab1/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>lab1的内容或者目的：</p>
<ul>
<li>熟悉x86的汇编语言，搭建环境：下载make qemu等，熟悉PC的开机流程</li>
<li>examine the boot loader for 6.828 kernel</li>
<li>initial template for 6.828 kernel ,named JOS<a id="more"></a>

</li>
</ul>
<h3 id="a-搭建环境：git-clone-qemu"><a href="#a-搭建环境：git-clone-qemu" class="headerlink" title="a. 搭建环境：git clone qemu"></a>a. 搭建环境：git clone qemu</h3><ul>
<li>完全参照 <a href="https://www.cnblogs.com/gatsby123/p/9746193.html" target="_blank" rel="noopener">https://www.cnblogs.com/gatsby123/p/9746193.html</a><br>之前用的其他的博客但是没搞好，这个博客解决了  </li>
<li>还遇到一个头文件缺失的问题: <a href="https://github.com/Ebiroll/qemu_esp32/issues/12" target="_blank" rel="noopener">https://github.com/Ebiroll/qemu_esp32/issues/12</a> 通过添加头文件通过了<br>学到的东西：  </li>
<li>知道了qemu是个跑在linux上的模拟器，可以模拟出各种硬件状态。在这个实验中，qemu的作用是模拟出i386的环境，因为这个实验写出的操作系统是跑在i386上的。</li>
</ul>
<h3 id="b-提交作业"><a href="#b-提交作业" class="headerlink" title="b. 提交作业"></a>b. 提交作业</h3><p>当完成代码后，可以在lab下 make grade,获得评分。  </p>
<h2 id="Part1：Bootstrap"><a href="#Part1：Bootstrap" class="headerlink" title="Part1：Bootstrap"></a>Part1：Bootstrap</h2><p>这个部分不写代码，主要是了解和学习汇编相关知识和开机引导流程</p>
<h3 id="a-汇编"><a href="#a-汇编" class="headerlink" title="a.汇编"></a>a.汇编</h3><ul>
<li>汇编有两种语法，一个是Intel的一个是AT&amp;T。x86一般用Intel语法，NASM（Netwide Assembly)是使用Intel语法的汇编器，GNU使用AT&amp;T语法</li>
<li>主要了解几种常见汇编指令   </li>
</ul>
<h3 id="b-qemu的使用"><a href="#b-qemu的使用" class="headerlink" title="b.qemu的使用"></a>b.qemu的使用</h3><ul>
<li>配置好qemu后，直接在lab下 make qemu,可以编译运行kernel  </li>
</ul>
<h3 id="c-PC的物理地址空间"><a href="#c-PC的物理地址空间" class="headerlink" title="c. PC的物理地址空间"></a>c. PC的物理地址空间</h3><figure class="highlight mercury"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>xFFFFFFFF (<span class="number">4</span>GB)   </span><br><span class="line">|      <span class="number">32</span>-bit      |   </span><br><span class="line">|  memory mapped   |   </span><br><span class="line">|     devices      |   </span><br><span class="line">|                  |   </span><br><span class="line"><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span>  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span><span class="built_in">/\</span>   </span><br><span class="line">|                  |   </span><br><span class="line">|      Unused      |   </span><br><span class="line">|                  |   </span><br><span class="line">+------------------+  &lt;- depends on amount of RAM   </span><br><span class="line">|                  |   </span><br><span class="line">|                  |   </span><br><span class="line">| Extended Memory  |     </span><br><span class="line">|                  |   </span><br><span class="line">|                  |   </span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x00100000 (<span class="number">1</span>MB)   </span><br><span class="line">|     BIOS ROM     |   </span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x000F0000 (<span class="number">960</span>KB)  </span><br><span class="line">|  <span class="number">16</span>-bit devices, |   </span><br><span class="line">|  expansion ROMs  |   </span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x000C0000 (<span class="number">768</span>KB)   </span><br><span class="line">|   VGA Display    |    </span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x000A0000 (<span class="number">640</span>KB)   </span><br><span class="line">|                  |   </span><br><span class="line">|    Low Memory    |   </span><br><span class="line">|                  |   </span><br><span class="line">+------------------+  &lt;- <span class="number">0</span>x00000000</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>16位的Intel 8088/86 有20位地址总线，可以寻址1MB的内存，但是由于数据总线只有16位，所以单个程序段最大只有64KB,为了可以寻址1MB，Intel引入了分段：<ul>
<li>逻辑段的开始地址必须是16的倍数，因为段寄存器长为16位；</li>
<li>逻辑段的最大长度为64K，因为指针寄存器长为16位。 </li>
<li>那么1M字节地址空间最多可划分成64K个逻辑段，最少也要划分成16个逻辑段。逻辑段与逻辑段可以相连，也可以不相连，还可以部分重叠。</li>
<li>在实模式下，cpu寻址的方式是：CS:IP  物理地址是： 16*CS+IP</li>
<li>这个博客说得很好  <a href="https://www.cnblogs.com/blacksword/archive/2012/12/27/2836216.html" target="_blank" rel="noopener">https://www.cnblogs.com/blacksword/archive/2012/12/27/2836216.html</a>  </li>
</ul>
</li>
<li>早期的cpu内存，只使用640KB以下的内存(被称为Low Memory)作为随机存取器（RAM），更早的使用的内存更少：16KB，32KB，64KB</li>
<li>640KB至1MB中间的384KB内存被保留作为硬件的特殊用途，比如显卡缓冲区和非易失固件内存（？）</li>
<li>被保留的最重要的区域是从0x000F0000（960KB）到0x000FFFFF（1MB）的64KB，这里会存放BIOS。BIOS会进行基本的初始化比如显卡检查和硬件检查以及内存检查</li>
<li>BIOS初始化之后会从适当的位置（软盘硬盘等）加载操作系统</li>
<li>从80286和80386开始Intel支持16MB和4GB内存，但是低1MB的基本功能布局没有变化（为了兼容）</li>
<li>现代PC在640KB到1MB之间有个hole，把内存分为了低640KB的Low Memory和1MB以上的extended memory</li>
<li>并且在32位机器上，4GB的内存顶部也保留了一部分区域给32位的PCI接口设备，因此在64位机器普及后，内存又出现了第二个hole</li>
<li>这个课程的操作系统只使用低256MB内存</li>
</ul>
<h3 id="d-The-ROM-BIOS"><a href="#d-The-ROM-BIOS" class="headerlink" title="d.The ROM BIOS"></a>d.The ROM BIOS</h3><ul>
<li>学习IA-32兼容的计算机是怎么开机的</li>
<li>打开两个终端，先后分别输入 make qemu-gdb make gdb,在输入make gdb的终端里可以使用相关gdb命令进行调试<ul>
<li>si代表执行下一个语句并停下来，显示出来的是即将执行的语句，但是还未执行</li>
</ul>
</li>
<li>BIOS加载进内存后，将从CS=0xf00 IP=0xfff0出执行，这个语句是个jmp语句，跳到CS=0Xf000 IP=0xe05b，原因是0xffff0处于BIOS末端（因为之前的语句是把BIOS加载进来，然后就到了末尾），要执行BIOS，则要跳转到BIOS的入口出</li>
<li>BIOS的功能是设置中断表、初始化设备，然后寻找一个可引导开机的设备（硬盘软盘等），然后读取开机引导设备的第一个扇区（里面的程序是bootloader）到内存0x7c00处（这个地址是随意的，但是是写死的，也就是说这个地址没什么特殊意义，只是刚好选了它，但它仍要满足一些条件，内存对齐、位置等），再跳转到bootloader的入口，控制权就转移到了bootloader  </li>
</ul>
<h2 id="Part2-The-Boot-Loader"><a href="#Part2-The-Boot-Loader" class="headerlink" title="Part2: The Boot Loader"></a>Part2: The Boot Loader</h2><ul>
<li>一般情况下，或者说老一代的PC其开机设备的第一个扇区存了bootloader，负责开机引导等，现代的PCbootloader会有更复杂的功能和大小</li>
<li>JOS的bootloader由一个汇编文件:boot/boot.S和C源文件：boot/main.c组成，里面的内容分析：</li>
<li>boot/boot.S</li>
</ul>
<figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;inc/mmu.h&gt;</span></span><br><span class="line"><span class="comment"># Start the CPU: switch to 32-bit protected mode, jump into C.</span></span><br><span class="line"><span class="comment"># The BIOS loads this code from the first sector of the hard disk into</span></span><br><span class="line"><span class="comment"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class="line"><span class="comment"># with %cs=0 %ip=7c00.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#.set symbol, expression 汇编意义：设置symbol为expression</span></span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, <span class="number">0x8</span>         <span class="comment"># kernel code segment selector   </span></span><br><span class="line"><span class="comment">#段选择符的格式:13位索引+1位TI表指示标志（代表是不是全局描述符）+2位RPL</span></span><br><span class="line"><span class="comment">#因此 0x8  0000000000001 0 00</span></span><br><span class="line"><span class="comment">#此处预设代码段选择符,这个选择符代表，索引是1，TI为0表示全局描述符，RPL权限设为最高</span></span><br><span class="line"></span><br><span class="line">.set PROT_MODE_DSEG, <span class="number">0x10</span>        <span class="comment"># kernel data segment selector</span></span><br><span class="line"><span class="comment">#     0x10 0000000000010 0 00</span></span><br><span class="line"><span class="comment">#此处预设数据段选择符,代表索引是2，全局描述符，权限0最高</span></span><br><span class="line"></span><br><span class="line">.set CR0_PE_ON,      <span class="number">0x1</span>         <span class="comment"># protected mode enable flag</span></span><br><span class="line"><span class="comment">#保护模式的设置由CR0管理，这里的标识符代表开启保护模式时CR0对应的位的值:最低位置位</span></span><br><span class="line"></span><br><span class="line">.globl start  </span><br><span class="line">start:                 <span class="comment">#函数的开始，相当于main</span></span><br><span class="line">  .code16                     <span class="comment"># Assemble for 16-bit mode    </span></span><br><span class="line">  <span class="comment">#让汇编器按照16位代码汇编</span></span><br><span class="line"></span><br><span class="line">  cli                         <span class="comment"># Disable interrupts</span></span><br><span class="line">  cld                         <span class="comment"># String operations increment</span></span><br><span class="line"><span class="comment">#关闭中断，设置字符串操作是递增方向</span></span><br><span class="line"><span class="comment">#cld的作用是将direct flag标志位清零</span></span><br><span class="line"><span class="comment">#it means that instructions that autoincrement the source index and destination index (like MOVS) will increase both of them</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Set up the important data segment registers (DS, ES, SS).</span></span><br><span class="line"></span><br><span class="line">  xorw    %ax,%ax             <span class="comment"># Segment number zero</span></span><br><span class="line">  movw    %ax,%ds             <span class="comment"># -&gt; Data Segment</span></span><br><span class="line">  movw    %ax,%es             <span class="comment"># -&gt; Extra Segment</span></span><br><span class="line">  movw    %ax,%ss             <span class="comment"># -&gt; Stack Segment</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable A20:</span></span><br><span class="line">  <span class="comment">#   For backwards compatibility with the earliest PCs, physical</span></span><br><span class="line">  <span class="comment">#   address line 20 is tied low, so that addresses higher than</span></span><br><span class="line">  <span class="comment">#   1MB wrap around to zero by default.  This code undoes this.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#激活A20地址位,由于需要兼容早期pc，物理地址的第20位绑定为0，所以高于1MB的地址又回到了0x00000</span></span><br><span class="line">  <span class="comment">#激活A20后，就可以访问所有4G内存，就可以使用保护模式</span></span><br><span class="line">  <span class="comment">#激活方式：由于历史原因A20地址位由键盘控制器芯片8042管理。所以要给8042发命令激活A20</span></span><br><span class="line">  <span class="comment">#8042有两个IO端口：0x60和0x64,激活流程为： 先发送0xd1命令到0x64端口 --&gt; 再发送0xdf到0x60</span></span><br><span class="line"></span><br><span class="line">seta2<span class="number">0</span>.<span class="number">1</span>:</span><br><span class="line">  inb     $0x64,%al               <span class="comment"># Wait for not busy</span></span><br><span class="line">  <span class="comment">#汇编语言有专门的读取端口信息的指令，in out后面的b代表一个字节</span></span><br><span class="line"></span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  <span class="comment">#测试（两操作数作与运算,仅修改标志位，不回送结果）。</span></span><br><span class="line"></span><br><span class="line">  jnz     seta2<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"><span class="comment">#发送命令之前，要等待键盘输入缓冲区为空，这通过8042的状态寄存器的第2bit来观察，而状态寄存器的值可以读0x64端口得到。</span></span><br><span class="line"><span class="comment">#上面的指令的意思就是，如果状态寄存器的第2位为1，就跳到seta20.1符号处执行，知道第2位为0，代表缓冲区为空</span></span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               <span class="comment"># 0xd1 -&gt; port 0x64</span></span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"><span class="comment">#发送0xd1到0x64端口</span></span><br><span class="line"></span><br><span class="line">seta2<span class="number">0</span>.<span class="number">2</span>:</span><br><span class="line">  inb     $0x64,%al               <span class="comment"># Wait for not busy</span></span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta2<span class="number">0</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               <span class="comment"># 0xdf -&gt; port 0x60</span></span><br><span class="line">  outb    %al,$0x6<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Switch from real to protected mode, using a bootstrap GDT</span></span><br><span class="line">  <span class="comment"># and segment translation that makes virtual addresses </span></span><br><span class="line">  <span class="comment"># identical to their physical addresses, so that the </span></span><br><span class="line">  <span class="comment"># effective memory map does not change during the switch.</span></span><br><span class="line">  <span class="comment">#转入保护模式，这里需要指定一个临时的GDT，来翻译逻辑地址。</span></span><br><span class="line">  <span class="comment">#这里使用的GDT通过gdtdesc段定义，它翻译得到的物理地址和虚拟地址相同（段描述符里的段基址为0）</span></span><br><span class="line">  <span class="comment">#所以转换过程中内存映射不会改变</span></span><br><span class="line"></span><br><span class="line">  lgdt    gdtdesc   </span><br><span class="line">  <span class="comment">#lgdt指令把gdtdesc的地址加载进gdtr寄存器，代表全局段描述符表</span></span><br><span class="line"></span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  <span class="comment">#开启保护模式</span></span><br><span class="line">  <span class="comment"># Jump to next instruction, but in 32-bit code segment.</span></span><br><span class="line">  <span class="comment"># Switches processor into 32-bit mode.</span></span><br><span class="line">  <span class="comment">#由于进入保护模式，所有地址都应该是：cs:eip</span></span><br><span class="line"></span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg         <span class="comment">#ljmp cs esp</span></span><br><span class="line">  <span class="comment">#Long jump, use 0xfebc for the CS register and 0x12345678 for the EIP register:</span></span><br><span class="line">  <span class="comment">#ljmp $0xfebc, $0x12345678</span></span><br><span class="line"></span><br><span class="line">  .code32                     <span class="comment"># Assemble for 32-bit mode</span></span><br><span class="line">protcseg:</span><br><span class="line">  <span class="comment"># Set up the protected-mode data segment registers</span></span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    <span class="comment"># Our data segment selector</span></span><br><span class="line">  movw    %ax, %ds                <span class="comment"># -&gt; DS: Data Segment</span></span><br><span class="line">  movw    %ax, %es                <span class="comment"># -&gt; ES: Extra Segment</span></span><br><span class="line">  movw    %ax, %fs                <span class="comment"># -&gt; FS</span></span><br><span class="line">  movw    %ax, %gs                <span class="comment"># -&gt; GS</span></span><br><span class="line">  movw    %ax, %ss                <span class="comment"># -&gt; SS: Stack Segment</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Set up the stack pointer and call into C.</span></span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line">  <span class="comment"># If bootmain returns (it shouldn't), loop.</span></span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bootstrap GDT</span></span><br><span class="line">.p2align <span class="number">2</span>                                <span class="comment"># force 4 byte alignment</span></span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL				<span class="comment"># null seg</span></span><br><span class="line">  SEG(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)	<span class="comment"># code seg</span></span><br><span class="line">  SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)	        <span class="comment"># data seg</span></span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   <span class="number">0x17</span>                            <span class="comment"># sizeof(gdt) - 1</span></span><br><span class="line">  .long   gdt                             <span class="comment"># address gdt</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>boot/boot.S的功能有一个：<ul>
<li>从实模式进入32位保护模式，方法是把CR0最低位置位，即开启了保护模式，然后激活A20使得cpu可以寻址1MB以上的空间，之后设置一个段表，最后调用bootmain，进入main.c</li>
</ul>
</li>
<li></li>
</ul>
<ul>
<li>stab的作用：<ul>
<li>With the <code>-g</code> option, GCC puts in the .s’ file additional debugging information, which is slightly transformed by the assembler and linker, and carried through into the nal executable. This debugging information describes features of the source file like line numbers, the types and scopes of variables, and function names, parameters, and scopes of variables, and function names, parameters, and scopes. </li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>mit6.828汇总</title>
    <url>/2021/02/18/mit6-828-hui-zong/</url>
    <content><![CDATA[<p>mit6.828的六个实验：<br><a href="https://artistarthur.github.io/ArtistArthur.github.io/2020/10/21/mit6-828-lab1/#more">Lab 1: C, Assembly, Tools, and Bootstrapping</a><br><a href="https://artistarthur.github.io/ArtistArthur.github.io/2020/11/30/mit6-828-lab2/#more">Lab 2: Memory management</a><br><a href="https://artistarthur.github.io/ArtistArthur.github.io/2020/12/02/mit6-828-lab3/#more">Lab 3: User-Level Environments</a><br><a href="https://artistarthur.github.io/ArtistArthur.github.io/2021/12/20/mit6-828-lab4/"> Lab 4: Preemptive Multitasking</a><br><a href="">Lab 5: File system, spawn, and sh</a><br><a href="">Lab 6: Networking</a>  </p>
<a id="more"></a><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>TCP/IP详解</title>
    <url>/2020/07/02/net-tcp-ip/</url>
    <content><![CDATA[<h1 id="计算机网络细节"><a href="#计算机网络细节" class="headerlink" title="计算机网络细节"></a>计算机网络细节</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="TCP慢启动"><a href="#TCP慢启动" class="headerlink" title="TCP慢启动"></a>TCP慢启动</h2><h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>发送方可以不必发送一个全窗口大小的数据。<br>来自接收方的一个确认报文段把窗口向右边滑动（左沿和右沿都有可能向右），并且窗口的大小是相对于确认序号的。<br>窗口大小可以变小，但是不可以左移。<br>接收方在发送一个ack时不必等待窗口被填满，一种情况是每收到两个报文段就会发送一个ack。  </p>
<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。<br>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>粘包 <a href="https://blog.csdn.net/weixin_41047704/article/details/85340311" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41047704/article/details/85340311</a><br>TCP的FIN包可以不是单独的，可以放在数据包中（并且会占有一个字节），FIN的ACK也不用单独的包，而是跟着数据包的确认一起。  </p>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>ICMP是IP协议的附属协议，IP层用它来与其他主机或者路由器交换错误报文和其他重要信息。尽管ICMP主要被IP使用，但应用程序也有可能访问它，比如Ping和Traceroute。</p>
<a id="more"></a>  
<h2 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h2><p>IGMP是Internet组管理协议(internet group management protocol)。它用来把一个UDP数据报多播到多个主机。</p>
<h2 id="ARP（地址解析协议-address-）-RARP（逆地址解析协议）"><a href="#ARP（地址解析协议-address-）-RARP（逆地址解析协议）" class="headerlink" title="ARP（地址解析协议 address ） RARP（逆地址解析协议）"></a>ARP（地址解析协议 address ） RARP（逆地址解析协议）</h2><p>ARP和RARP是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>32位IP地址分为五类： </p>
<ul>
<li>A类 0.0.0.0 ~ 127.255.255.255 </li>
<li>B类 128.0.0.0 ~ 191.255.255.255</li>
<li>C类 192.0.0.0 ~ 223.255.255.255</li>
<li>D类 224.0.0.0 ~ 239.255.255.255</li>
<li>E类 240.0.0.0 ~ 247.255.255.255</li>
</ul>
<p>多接口主机有多个IP地址，每一个接口都对应一个IP地址。<br>有三类IP地址：</p>
<ul>
<li>单播地址：目的为单个主机</li>
<li>广播地址：目的端为给定网络上的所有主机</li>
<li>多播地址：目的端为同一组内的所有主机</li>
<li>待解决：什么是一个网络，什么是一个组</li>
</ul>
<h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><p>TCP向应用层提供一种面向连接的、可靠的字节流服务。<br>面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。<br>在一个TCP连接中，仅有两方进行彼此通信，广播和多播不能用于TCP。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>mit6.828-lab3</title>
    <url>/2020/12/02/mit6-828-lab3/</url>
    <content><![CDATA[<h2 id="mit6-828-lab3-user-environments"><a href="#mit6-828-lab3-user-environments" class="headerlink" title="mit6.828-lab3:user environments"></a>mit6.828-lab3:user environments</h2><p>在这个lab里你将:</p>
<ul>
<li>完成基本的用户进程相关设施和数据结构(envs struct等). </li>
<li>加载一个程序镜像到内存并运行它.</li>
<li>完成中断/异常,系统调用的相关设施,让kernel有能力处理中断/异常和系统调用.  <a id="more"></a>
<h3 id="partA-user-environments-and-exception-handling"><a href="#partA-user-environments-and-exception-handling" class="headerlink" title="partA:user environments and exception handling"></a>partA:user environments and exception handling</h3>首先是用户相关的数据结构<code>Env</code>:<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="keyword">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env's parent</span></span><br><span class="line">	<span class="keyword">enum</span> EnvType env_type;		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="keyword">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="keyword">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="keyword">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<!--more-->      
进程上下文切换的相关结构:   <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> {</span></span><br><span class="line">	<span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> reg_edi;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_esi;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_ebp;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_oesp;		<span class="comment">/* Useless */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> reg_ebx;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_edx;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_ecx;</span><br><span class="line">	<span class="keyword">uint32_t</span> reg_eax;</span><br><span class="line">} __attribute__((packed));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">} __attribute__((packed));</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_pop_tf(struct Trapframe *tf)</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tmovl %0,%%esp\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopal\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%es\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tpopl %%ds\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\taddl $0x8,%%esp\n"</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="string">"\tiret\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		: : <span class="string">"g"</span> (tf) : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">	panic(<span class="string">"iret failed"</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<code>%0</code>表示<code>tf</code>代表的寄存器,<code>movl %0,%%esp</code>把<code>tf</code>的地址存入<code>esp</code>寄存器中,<code>popal</code>是<code>popa</code>的长指令(pop all).<br><code>pusha</code>作用是:把八个通用寄存器全部<code>push</code>入<code>esp</code>中,顺序为<code>eax ecx edx ebx oldesp ebp esi edi</code>而<code>popa</code>的作用相反:从<code>esp</code>中把这八个值弹出到相应的寄存器,但是并不弹出<code>old_esp</code>,会跳过它,方式是<code>esp</code>+4.<br>IRET是一个汇编指令,这个指令会做很多事情:<br>the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure. If the return is to another privilege level, the IRET instruction also pops the stack pointer and SS from the stack, before resuming program execution.  </li>
</ul>
<figure class="highlight oxygene"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">Operation</span><br><span class="line"><span class="keyword">IF</span> OperandSize = <span class="number">32</span> <span class="comment">(* instruction = POPAD *)</span></span><br><span class="line"><span class="keyword">THEN</span></span><br><span class="line">EDI ← Pop();</span><br><span class="line">ESI ← Pop();</span><br><span class="line">EBP ← Pop();</span><br><span class="line">increment ESP <span class="keyword">by</span> <span class="number">4</span> <span class="comment">(* skip next 4 bytes of stack *)</span></span><br><span class="line">EBX ← Pop();</span><br><span class="line">EDX ← Pop();</span><br><span class="line">ECX ← Pop();</span><br><span class="line">EAX ← Pop();</span><br><span class="line"><span class="keyword">ELSE</span> <span class="comment">(* OperandSize = 16, instruction = POPA *)</span></span><br><span class="line">DI ← Pop();</span><br><span class="line">SI ← Pop();</span><br><span class="line">BP ← Pop();</span><br><span class="line">increment ESP <span class="keyword">by</span> <span class="number">2</span> <span class="comment">(* skip next 2 bytes of stack *)</span></span><br><span class="line">BX ← Pop();</span><br><span class="line">DX ← Pop();</span><br><span class="line">CX ← Pop();</span><br><span class="line">AX ← Pop();</span><br><span class="line">参考资料:https:<span class="comment">//www.cs.cmu.edu/~410/doc/intel-isr.pdf</span></span><br></pre></td></tr></tbody></table></figure>
<p>参考:<a href="https://www.cnblogs.com/whutzhou/articles/2638498.html" target="_blank" rel="noopener">https://www.cnblogs.com/whutzhou/articles/2638498.html</a><br><code>env_pop_tf()</code>的作用是:转到<code>tf</code>代表的用户程序,先把<code>esp</code>设为这个<code>Trapframe</code>的地址,然后<code>popa</code>,即从<code>tf</code>中的<code>struct PushRegs tf_regs</code>弹出值到相应的寄存器,实现上下文的切换.然后再从<code>tf</code>中弹出<code>es</code>和<code>ds</code>的值,再跳过<code>tf_trapno and tf_errcode</code>,最后<code>iret</code>.<br>值得注意的是:栈是从上往下增长的,<code>tf</code>陷阱门是从下网上长的,因此把<code>esp</code>设为<code>tf</code>,<code>pop</code>弹出值的时候,<code>esp</code>回退(即往上),对应着<code>tf</code>往上依次读取成员.</p>
<h4 id="exercise2"><a href="#exercise2" class="headerlink" title="exercise2"></a>exercise2</h4><p>完成几个函数:</p>
<ul>
<li><code>env_init()</code>:初始化所有的在<code>envs</code>数组中的<code>Enc</code>结构体,并把他们添加到<code>env_free_list</code>指针后面,之后调用<code>env_init_per_cpu</code>以设置段管理的相关硬件,它们分别是特权级0(kernel)和特权级3(user)的段.</li>
<li><code>env_setup_vm()</code>:为新的<code>environment</code>分配一个页目录表,并且初始化新的地址空间中的内核部分(通过复制).</li>
<li><code>region_alloc()</code>:为新的<code>environment</code>分配并映射物理地址.</li>
<li><code>load_icode()</code>:需要自己实现解析ELF二进制文件的功能(就和<code>bootloader</code>里面做的一样),并把二进制文件的内容加载到新的<code>environment</code>的用户地址空间中.</li>
<li><code>env_create</code>:通过<code>env_alloc()</code>分配一个<code>environment</code>,并且调用<code>load_icode()</code>把ELF二进制文件加载进去.</li>
<li><code>env_run</code>:在用户模式下启动一个给定的<code>environment</code>.<br>代码解析:  </li>
<li><code>env_init()</code>:  </li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Mark all environments in 'envs' as free, set their env_ids to 0,</span></span><br><span class="line"><span class="comment">// and insert them into the env_free_list.</span></span><br><span class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></span><br><span class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></span><br><span class="line"><span class="comment">// env_alloc() returns envs[0]).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">	env_free_list = envs;</span><br><span class="line">    <span class="comment">//让env_free_list等于数组第一个元素,再让整个数组通过链表连起来</span></span><br><span class="line">    <span class="comment">//env_link指向下一个节点,同时把id设置为0</span></span><br><span class="line">    <span class="comment">//让最后一个节点指向null</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NENV<span class="number">-1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		envs[i].env_link = envs + i + <span class="number">1</span>;</span><br><span class="line">		envs[i].id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	(envs + NENV - <span class="number">1</span>)-&gt;env_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>env_setup_vm():</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></span><br><span class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></span><br><span class="line"><span class="comment">// and initialize the kernel portion of the new environment's address space.</span></span><br><span class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></span><br><span class="line"><span class="comment">// of the environment's virtual address space.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if page directory or table could not be allocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we've set below).</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir's</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	e-&gt;env_pgdir =(<span class="keyword">pde_t</span>*) page2kva(p);</span><br><span class="line">	<span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	<span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>region_alloc</code>:<br>为进程分配<code>len</code>个字节的物理内存并且映射到<code>va</code>所代表的虚拟地址上,不要设置0或者初始化被映射的页(page_alloc()传0进去就可以).<br>页面的权限应该是用户和内核都可写的.<br>如果分配失败则<code>panic</code>  </li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></span><br><span class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></span><br><span class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></span><br><span class="line"><span class="comment">// Pages should be writable by user and kernel.</span></span><br><span class="line"><span class="comment">// Panic if any allocation attempt fails.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">	<span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">	<span class="keyword">void</span> *low = ROUNDDOWN(va, PGSIZE);<span class="comment">//向下取整,即把va所在的那一页全部映射,从va前面页面对齐开始</span></span><br><span class="line">	<span class="keyword">void</span> *up = ROUNDUO(va + len, PGSIZE);<span class="comment">//向上取整</span></span><br><span class="line">	<span class="keyword">for</span> (; low &lt; up;low+=PGSIZE)</span><br><span class="line">	{</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> = <span class="title">page_alloc</span>(0);</span></span><br><span class="line">		<span class="keyword">if</span>(!p)</span><br><span class="line">		{</span><br><span class="line">			panic(<span class="string">"region_alloc error: region_alloc failed!\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		p-&gt;pp_ref++;</span><br><span class="line">		page_insert(e-&gt;env_pgdir, p, low, PTE_W|PTE_U);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>load_icode</code>:<br>为用户进程设置初始的二进制程序,栈,处理器标志等.<br>这个函数只在内核初始化的时候被调用,在运行第一个用户态进程之前.<br>这个函数从二进制镜像加载所有可加载的段到进程的内存中,从适当的、二进制文件头里描述的虚拟地址开始.<br>同时它把在二进制头里要求的一些段的内容设置为0,比如<code>bss segment</code>.<br>这些和我们的<code>boot loader</code>所做的很像,但是它是从硬盘读取代码.去参考下<code>boot/main.c</code>里的代码.<br>最后,这个函数从这个进程的初始栈映射一个页.<br>如果它遇到任何问题,则会<code>panic</code>,请思考它在什么情况下会出错.</li>
</ul>
<h4 id="the-task-state-segment"><a href="#the-task-state-segment" class="headerlink" title="the task state segment"></a>the task state segment</h4><p>处理器需要一个地方储存中断或者异常发生之前的处理器状态,比如<code>EIP</code>和<code>CS</code>的值,以便当异常或者中断执行完毕后可以恢复cpu的状态,并从原来的程序位置重新执行.<br>但是这个储存的地方,也必须免受权限不够的用户态程序影响,否则一些恶意程序会影响kernel.<br>因此x86处理器当特权级切换的时候也会切换栈,<code>TSS</code>任务状态段的目的便是服务这一过程,它指定了段选择符并指出这个栈在段中的位置,处理器会<code>push</code> <code>SS,ESP,EFLAGS,CS,EIP</code>和error code到这个栈里(error code只有某些中断或者异常会有,有的没有).随后处理器从中断描述符中加载<code>CS</code>和<code>EIP</code>以切换到新栈.<br>在JOS的实现中,当处理器从中断描述符中加载<code>CS</code>和<code>EIP</code>后,接下来的指令开始压入error code(如果cpu之前没有压的话),trap编号,然后<code>call _alltraps</code>,压入<code>ds es</code>然后<code>pushal</code>等等,目的是在kernel的栈上构造一个<code>Trapframe</code>,它保存了中断前进程的状态,在<code>trap()</code>中会复制这个结构体到<code>curenv-&gt;env_tf</code>中,以便之后恢复现场.<br>以上的意思是:当转移控制权时,如果特权级发生变化,那么先要把当前处理器状态存入一个安全的<code>TSS</code>指定的栈中,再切换到目的栈,这个过程涉及到三个栈:当前栈,<code>TSS</code>指定的栈和将要转移到的代码段的栈.    </p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">http:<span class="comment">//blog.chinaunix.net/uid-685034-id-2076045.html  </span></span><br><span class="line">堆栈切换和任务切换</span><br><span class="line">堆栈切换</span><br><span class="line">中断发生时,从用户堆栈切换到内核堆栈是硬件完成的是吗？需要软件上哪些支持呢？</span><br><span class="line">x86处理器是由硬件完成的.</span><br><span class="line">但很多RISC(reduced instruction <span class="keyword">set</span> computer,精简指令集计算机,例如：MIPS R3000、HP—PA8000系列,Motorola M88000等均属于RISC微处理器)处理器必须由软件来实现用户态与核态之间的堆栈切换</span><br><span class="line">X86是CISC处理器(复杂指令集计算机(Complex Instruction Set Computer,CISC))</span><br><span class="line">X86处理器的SP切换过程是这样的：</span><br><span class="line"></span><br><span class="line">当中断或异常发生时,处理器会检查是否有CPU运行级别的改变,如果有的话,则进行堆栈切换.切换的过程如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 读取TR寄存器以便访问当前进程的TSS段,因为TSS段中保存着当前进程在核心态下的堆栈指针.</span><br><span class="line"><span class="number">2.</span> 从TSS段中加载相应的堆栈地址到SS和ESP寄存器中.</span><br><span class="line"><span class="number">3.</span> 在核态堆栈中,保存用户态下的SS寄存器和ESP寄存器值.</span><br><span class="line"></span><br><span class="line">由于linux内核仅使用了一个TSS段,因此当发生进程切换时,内核必须将新进程的核态堆栈更新到TSS段中.</span><br><span class="line"></span><br><span class="line">而对于RISC处理器而言, 本着“简洁”的设计原则,当发生中断或异常时,CPU仅仅只是跳转到某个TRAP向量地址去执行(当然,硬件还是会自动设置处理器状态寄存器PSR中的核心态标志位,同时保存trap发生前的处理器运行级别),而其余的工作就都统统留给软件去完成了.</span><br><span class="line"></span><br><span class="line">因此,RISC处理器的trap handler通常都做这样的一些工作：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>根据trap发生前的处理器运行级别判断是否需要进行堆栈切换. 如果trap发生之前就是处在核心态下,那显然就不要切换堆栈.而是直接去做SAVE_ALL好了.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 如果之前是用户态,那么从内核的某个固定的地址加载当前进程的核态SP指针.然后进行SAVE_ALL保存中断现场.</span><br><span class="line">#####</span><br><span class="line">我们知道每个进程都有一个用户堆栈与系统堆栈,那么此外是否还有一个操作系统内核专用的堆栈呢？</span><br><span class="line">BTW：内核代码都是运行在当前进程的核心态堆栈中的,并不需要专门的堆栈</span><br><span class="line">########</span><br><span class="line">那么当系统初始化时,系统中第一个进程还没有生成的时候,用的是哪个堆栈呢？</span><br><span class="line">从head.s程序起,系统开始正式在保护模式下运行.此时堆栈段被设置为内核数据段(<span class="number">0x10</span>),堆栈指针esp设置成指向user_stack数组的顶端,保留了<span class="number">1</span>页内存(<span class="number">4</span>K)最为堆栈使用.此时该堆栈是内核程序自己使用的堆栈.</span><br><span class="line">(有疑问的答案：系统初始化用的是<span class="number">0</span>进程的堆栈 －－ 也就是是init_task的堆栈.</span><br><span class="line">整个start_kernel()都是在init_task的堆栈中执行的.start_kernel()最后clone出<span class="number">1</span>进程－－也就是init进程.然后<span class="number">0</span>进程就去执行cpu_idle()函数了－－也就是变成idle进程了.然后发生一次进程调度(进程切换时会切换内核堆栈),init进程得到运行,此时内核就在init进程的堆栈中运行.)</span><br><span class="line">#####</span><br><span class="line">任务<span class="number">0</span>的堆栈</span><br><span class="line">    任务<span class="number">0</span>的堆栈比较特殊,在执行了move_to_user_mode()之后,它的内核堆栈位于其任务数据结构所在页面的末端,而它的用户态堆栈就是前面进入保护模式后所使用的堆栈,即user_stack数组的位置.任务<span class="number">0</span>的内核态堆栈是在其人工设置的初始化任务数据结构中指定的,而它的用户态堆栈是在执行move_to_user_mode()时,在模拟iret返回之前的堆栈中设置的.在该堆栈中,esp仍然是user_stack中原来的位置,而ss被设置成<span class="number">0x17</span>,也即用户局部表中的数据段,也即从内存地址<span class="number">0</span>开始并且限长<span class="number">640</span>KB的段.</span><br><span class="line"> </span><br><span class="line">任务切换</span><br><span class="line">I386硬件任务切换机制</span><br><span class="line"> </span><br><span class="line"><span class="number">1.</span>I386硬件任务切换机制</span><br><span class="line">　　 Intel 在i386体系的设计中考虑到了进程的管理和调度,并从硬件上支持任务间的切换.为此目的,Intel在i386系统结构中增设了一种新的段“任务状态段”TSS.一个TSS虽然说像代码段,数据段等一样,也是一个段,实际上却是一个<span class="number">104</span>字节的数据结构,用以记录一个任务的关键性的状态信息.</span><br><span class="line">　　 像其他段一样,TSS也要在段描述表中有个表项.不过TSS只能在GDT中,而不能放在任何一个LDT中或IDT中.若通过一个段选择项访问一个TSS,而选择项中的TI位为<span class="number">1</span>,就会产生一次GP异常.</span><br><span class="line">　　 另外,CPU中还增设一个任务寄存器TR,指向当前任务的TSS.相应地,还增加了一条指令LTR,对TR寄存器进行装入操作.像CS和DS一样,TR也有一个程序不可见部分,每当将一个段选择码装入到TR中时,CPU就会自动找到所选择的TSS描述项并将其装入到TR的程序不可见部分,以加速以后对该TSS段的访问.</span><br><span class="line">　　 还有,在IDT表中,除了中断门、陷阱门和调用门以为,还定义了一种任务门.任务门中包含一个TSS段选择码.当CPU因中断而穿过一个任务门时,就会将任务门中的选择码自动装入TR,使TR指向新的TSS,并完成任务的切换.CPU还可以通过JMP和CALL指令实现任务切换,当跳转或调用的目标段实际上指向GDT表中的一个TSS描述项时,就会引起一次任务切换.</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">内核栈的实现</span><br><span class="line">以linux内核为例,内核在创建进程并时,首先需要给进程分配task_struct结构体,在做这一步的时候内核实际上分配了两块连续的物理空间(一般是<span class="number">1</span>个物理页),上边供堆栈使用,下边保存进程描述符task_struct.这个整体叫做进程的内核栈,因此task_struct是在进程内核栈内部的.</span><br><span class="line">当为内核栈分配地址空间的时候,分配一个页面(这里以<span class="number">8</span>k为例)返回的地址是该该页面的低地址,而栈是由高地址向低地址增长的,栈顶指针只需将该内核栈的首地址+<span class="number">8</span>k即可</span><br></pre></td></tr></tbody></table></figure>

<h4 id="nested-exceptions-and-interrupt"><a href="#nested-exceptions-and-interrupt" class="headerlink" title="nested exceptions and interrupt"></a>nested exceptions and interrupt</h4><p>在用户态和内核态处理器都可以接受异常和中断,但是x86只有从用户态切换到内核态的时候才会在储存cpu当前状态时自动切换栈(其他时候不会),然后再从中断向量表中invoke适当的中断或异常.<br>如果处理器以及处于内核态了(即<code>CS</code>的低2位为0),那么处理器只是把当前处理器状态再次储存到当前栈中而不切换栈.下面在<code>system call</code>中我们可以看到这个特性的好处.<br>如果处理器已经在内核态了,并出发了嵌套异常,由于它不用切换栈,因此<code>SS</code>和<code>ESP</code>寄存器的状态就没有必要储存了,因此只需储存 <code>EFLAGS,CS,EIP</code>和error code,如果内核栈已经满了,这个时候再次出现中断或者异常, <code>EFLAGS,CS,EIP</code>压不进去了,就会出现不能恢复原来现场的功能,这是一个bug,处理器面对这样的情况时,粗暴地重置自己,设计kernel的时候应该避免这种情况.  </p>
<p>There are two sources for external interrupts and two sources for<br>exceptions:</p>
<ol>
<li>Interrupts</li>
</ol>
<ul>
<li>Maskable interrupts, which are signalled via the INTR pin.</li>
<li>Nonmaskable interrupts, which are signalled via the NMI<br>(Non-Maskable Interrupt) pin.</li>
</ul>
<ol start="2">
<li>Exceptions</li>
</ol>
<ul>
<li>Processor detected. These are further classified as faults, traps,<br>and aborts.</li>
<li>Programmed. The instructions INTO, INT 3, INT n, and BOUND can<br>trigger exceptions. These instructions are often called “software<br>interrupts”, but the processor handles them as exceptions.<br>INTR是一个外部中断请求触发器,这个触发器可以传递中断,INTR为“1”时(即有设备请求中断),表示该设备向CPU提出中断请求.但是设备如果要提出中断请求,其设备本身必须准备就绪,即接口内的完成触发器D的状态必须为“1”.MASK为中断屏蔽触发器,如果是“1”,中断会被屏蔽掉,封锁中断源的请求.仅当设备准备就绪(D=1),且该设备未被屏蔽(MASK=0)时,CPU的中断查询信号可将中断请求触发器置“1”.<br>NMI是2号中断,它由cpu直接使用,操作系统不能使用,它用来处理一些严重的突发情况比如电源掉电、存储器读写出错、总线奇偶位出错等.NMI线上中断请求是不可屏蔽的(即无法禁止的)、而且立即被CPU锁存.因此NMI是边沿触发,不需要电平触发.NMI的优先级也比INTR高.不可屏蔽中断的类型指定为2,在CPU响应NMI时,不必由中断源提供中断类型码,因此NMI响应也不需要执行总线周期INTA.   </li>
</ul>
<h4 id="setting-up-the-idt"><a href="#setting-up-the-idt" class="headerlink" title="setting up the idt"></a>setting up the idt</h4><p>下面我们将设置idt去处理0-31的异常和中断,system call和32-47的中断和异常会在以后的lab实现.<br><code>inc/trap.h</code>和<code>kern/trap.h</code>中有中断和异常的相关定义,<code>kern/trap.h</code>中定义的只用在kernel里,<code>inc/trap.h</code>中定义的在用户程序中也会起作用.<br>note:0-31中有intel保留的项,这些项随便自己怎么处理.<br>每个异常或者中断都应该在<code>trapentry.S</code>中有它自己的handler,并且<code>trap_init()</code>应该用这些handler的地址初始化IDT.每个handler应该在栈上建立一个<code>struct Trapframe</code>并且通过一个指向Trapframe的地址call<code>trap()</code>.然后<code>trap()</code>会处理异常/中断,或者交给另一个处理函数处理.  </p>
<h4 id="exercise-4"><a href="#exercise-4" class="headerlink" title="exercise 4"></a>exercise 4</h4><p>任务:编辑<code>trapentr.S</code>和<code>trap.c</code>并且实现上述描述的功能,<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code>宏可以帮到你,<code>T_*</code>也可以.你需要在<code>trapentry.S</code>为每一个<code>trap</code>添加entry point,你需要提供<code>TRAPHANDLER</code>指向的<code>_alltrap</code>函数,你也要修改<code>trap_init()</code>去初始化idt使得它指向每个entry point,<code>SETGAE</code>宏会帮到你.  </p>
<ul>
<li><code>_alltrap</code>应该:<ul>
<li>push values 以让栈看起来像一个<code>struct Trapframe</code></li>
<li>把<code>GD_KD</code>(kernel data段)加载进<code>%ds</code>和<code>%es</code>中 (怎么加载?我一开始用的<code>movl $GD_KD %ds</code>,但是报错了,原因是段寄存器不能通过立即数赋值,只能通过通用寄存器或存储器赋值,因此使用`pushl $GD_KD popl %ds)</li>
<li><code>pushl %esp</code>把地址传给<code>Trapframe</code>将作为一个<code>trap()</code>的一个参数</li>
<li>call <code>trap()</code> trap可以返回吗?//不可以</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* See COPYRIGHT for copyright information. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/memlayout.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/trap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###################################################################</span><br><span class="line"><span class="meta"># exceptions/interrupts</span></span><br><span class="line">###################################################################</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TRAPHANDLER defines a globally-visible function for handling a trap.  TRAPHANDLER为处理中断/异常定义了一个全局可见的函数</span></span><br><span class="line"><span class="comment"> * It pushes a trap number onto the stack, then jumps to _alltraps.		这个函数把trap number压栈然后跳转到 _alltraps函数</span></span><br><span class="line"><span class="comment"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.	TRAPHANDLER用在处理器自动压栈错误码的中断/异常中(即有错误码的中断/异常,没有错误码的用下面的TRAPHANDLER_NOEC函数处理)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You shouldn't call a TRAPHANDLER function from C, but you may	不能够在c语言程序中调用TRAPHANDLER</span></span><br><span class="line"><span class="comment"> * need to _declare_ one in C (for instance, to get a function pointer	但是需要在c语言程序中声明TRAPHANDLER定义的函数</span></span><br><span class="line"><span class="comment"> * during IDT setup).  You can declare the function with	以便于在建立idt的时候获得相应函数指针</span></span><br><span class="line"><span class="comment"> *   void NAME();											声明方式是: void name();</span></span><br><span class="line"><span class="comment"> * where NAME is the argument passed to TRAPHANDLER.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER(name, num)						\</span></span><br><span class="line">	.globl name;		<span class="comment">/* define global symbol for 'name' */</span>	\</span><br><span class="line">	.type name, @function;	<span class="comment">/* symbol type is function */</span>		\</span><br><span class="line">	.align <span class="number">2</span>;		<span class="comment">/* align function definition */</span>		\</span><br><span class="line">	name:			<span class="comment">/* function starts here */</span>		\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span></span><br><span class="line"><span class="comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span></span><br><span class="line"><span class="comment"> * format in either case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER_NOEC(name, num)					\</span></span><br><span class="line">	.globl name;							\</span><br><span class="line">	.type name, @function;						\</span><br><span class="line">	.align <span class="number">2</span>;							\</span><br><span class="line">	name:								\</span><br><span class="line">	pushl $<span class="number">0</span>;							\</span><br><span class="line">	pushl $(num);							\</span><br><span class="line">	jmp _alltraps</span><br><span class="line"></span><br><span class="line">.<span class="built_in">text</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for generating entry points for the different traps.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	TRAPHANDLER_NOEC(traphd0,<span class="number">0</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd1,<span class="number">1</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd2,<span class="number">2</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd3,<span class="number">3</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd4,<span class="number">4</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd5,<span class="number">5</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd6,<span class="number">6</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd7,<span class="number">7</span>)</span><br><span class="line">	TRAPHANDLER(traphd8,<span class="number">8</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd9,<span class="number">9</span>)</span><br><span class="line">	TRAPHANDLER(traphd10,<span class="number">10</span>)</span><br><span class="line">	TRAPHANDLER(traphd11,<span class="number">11</span>)</span><br><span class="line">	TRAPHANDLER(traphd12,<span class="number">12</span>)</span><br><span class="line">	TRAPHANDLER(traphd13,<span class="number">13</span>)</span><br><span class="line">	TRAPHANDLER(traphd14,<span class="number">14</span>)</span><br><span class="line">	TRAPHANDLER_NOEC(traphd16,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lab 3: Your code here for _alltraps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//根据Trapframe结构可以看出,处理器已经把SS,ESP,EFLAGS,CS,EIP压栈了</span></span><br><span class="line"><span class="comment">//上面的函数又把error code和trap number压栈了</span></span><br><span class="line"><span class="comment">//剩下只有ds es还有pusha对应的没有压了</span></span><br><span class="line"><span class="comment">//再根据实验提示,把GD_KD加载进ds和es最后call trap</span></span><br><span class="line">_alltraps:</span><br><span class="line">	pushl %ds</span><br><span class="line">	pushl %es</span><br><span class="line">	pushal </span><br><span class="line">	movl $GD_KD %ds</span><br><span class="line">	movl $GD_KD %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></tbody></table></figure>
<h5 id="the-breakpoint-exception"><a href="#the-breakpoint-exception" class="headerlink" title="the breakpoint exception"></a>the breakpoint exception</h5><p>断点异常被用来允许debugger在一个程序中插入断点,方式是临时把程序中的某个位置的代码用<code>int3</code>代替,<code>int3</code>是一个一字节的汇编代码,因此可以放入几乎所有地方.因此当程序执行到这个地方的时候,就会发生中断,进而运行相应的中断程序,这个时候往往可以看到程序的上下文内容,以此来调试代码.<br>JOS把3号中断向量的处理程序设为<code>monitor()</code>,因此发生断点异常的时候,将会进入<code>monitor()</code>程序.<br>Questions<br>4. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?<br>break point 的dpl应该设为3,因为用户态程序也会用到.否则会因为权限不够而产生一般保护性异常.<br>5. What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?   </p>
<h5 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h5><p>c<br>对于用户程序来说,执行<code>cprintf()</code>等函数需要调用系统调用.<br>比如一个用户程序执行<code>cprintf()</code>,这是<code>lib/printf.c</code>下的函数,是一个普通函数,但是这个函数需要IO输出,就涉及到kernel的资源调度,因此需要通过系统调用完成,它最终会调用<code>sys_cputs()</code>,这个函数又会调用<code>lib/syscall.c</code>中的<code>syscall()</code>,这个函数先通过汇编将函数参数压入通用寄存器,通过这个方式传递参数给即将产生的<code>int 0x30</code>中断.  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">int</span> num, <span class="keyword">int</span> check, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generic system call: pass system call number in AX,</span></span><br><span class="line">	<span class="comment">// up to five parameters in DX, CX, BX, DI, SI.</span></span><br><span class="line">	<span class="comment">// Interrupt kernel with T_SYSCALL.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The "volatile" tells the assembler not to optimize</span></span><br><span class="line">	<span class="comment">// this instruction away just because we don't use the</span></span><br><span class="line">	<span class="comment">// return value.</span></span><br><span class="line">	<span class="comment">//c</span></span><br><span class="line">	<span class="comment">// The last clause tells the assembler that this can</span></span><br><span class="line">	<span class="comment">// potentially change the condition codes and arbitrary</span></span><br><span class="line">	<span class="comment">// memory locations.</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"int %1\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">		     : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">		     : <span class="string">"i"</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="string">"a"</span> (num),</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="string">"d"</span> (a1),</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="string">"c"</span> (a2),</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="string">"b"</span> (a3),</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="string">"D"</span> (a4),</span></span></span><br><span class="line"><span class="function"><span class="params">		       <span class="string">"S"</span> (a5)</span></span></span><br><span class="line"><span class="function"><span class="params">		     : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"syscall %d returned %d (&gt; 0)"</span>, num, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>之后交给中断处理程序来处理相应的函数.这里会通过<code>trap_dispatch()</code>传递给<code>kern/syscall.c</code>中的<code>syscall()</code>,该函数根据系统调用调用号调用<code>kern/print.c</code>中的<code>cprintf()</code>函数,该函数最终调用<code>kern/console.c</code>中的<code>cputchar()</code>将字符串打印到控制台.当<code>trap_dispatch()</code>返回后,<code>trap()</code>会调用<code>env_run(curenv)</code>;,该函数会将<code>curenv-&gt;env_tf</code>结构中保存的寄存器快照重新恢复到寄存器中,这样又会回到用户程序系统调用之后的那条指令运行,只是这时候已经执行了系统调用并且寄存器<code>eax</code>中保存着系统调用的返回值.任务完成重新回到用户模式CPL=3.<br>对比一下普通的函数调用和中断以及系统调用参数传递的区别:</p>
<ul>
<li>普通函数掉用,如果没有特权级的变化,堆栈不会改变,函数调用过程是:<ul>
<li>先从右往左先把参数入栈,然后跳转到被调函数的地址</li>
<li>被调函数开始:把ebp压栈(先esp-1,然后把ebp的值存入esp),然后把esp的值赋给ebp.被调用函数通过esp+x(即往回找)来获得参数.  </li>
<li>最后函数会把返回值存入eax寄存器,主调函数通过eax寄存器获得返回值.  </li>
</ul>
</li>
<li>中断是先保存所有寄存器的值然后调用其他函数,返回的时候恢复现场,对程序运行没有影响.</li>
<li>系统调用先调用普通函数,然后把参数压入eax等通用寄存器来传递参数.中断完成之后返回现场,但会把返回值通过<code>tf-&gt;tf_regs.reg_eax=syscall()</code>写入eax中,被调用的普通函数把ret写入eax返回给主调函数.    </li>
<li>可变参数:</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>中断和异常一般是在程序运行过程中发生的,这个时候cpu执行 INT n指令,</p>
<h4 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h4><p>bootstack在哪里?<br>kernel的初始化代码<code>entry.S</code>里,由编译器分配<br>并且本质上esp的位置决定了栈的位置,因此只需要把esp置为想要的栈的位置就行了,栈的增长方式和具体细节由编译器提前决定(即设好规则,当什么时候,增长多少)</p>
<figure class="highlight perl"><table><tbody><tr><td class="code"><pre><span class="line">mov	$relocated, %eax</span><br><span class="line">	jmp	*%eax</span><br><span class="line">relocated:</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Clear the frame pointer register (EBP)</span></span><br><span class="line">	<span class="comment"># so that once we get into debugging C code,</span></span><br><span class="line">	<span class="comment"># stack backtraces will be terminated properly.</span></span><br><span class="line">	movl	$0<span class="keyword">x</span><span class="number">0</span>,%ebp			<span class="comment"># nuke frame pointer</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Set the stack pointer</span></span><br><span class="line">	<span class="comment">#这个位置设置的内核用栈,因为esp决定了栈的位置</span></span><br><span class="line">	movl	$(bootstacktop),%esp</span><br><span class="line"></span><br><span class="line">	<span class="comment"># now to C code</span></span><br><span class="line">	call	i386_init</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight clean"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">.data</span><br><span class="line">###################################################################</span><br><span class="line"># boot stack</span><br><span class="line">###################################################################</span><br><span class="line">	.p2align	PGSHIFT		# force page alignment</span><br><span class="line">	.globl		bootstack</span><br><span class="line">bootstack:</span><br><span class="line">	.space		KSTKSIZE <span class="comment">//32K</span></span><br><span class="line">	.globl		bootstacktop   </span><br><span class="line">bootstacktop:</span><br></pre></td></tr></tbody></table></figure>
<p>用户进程怎么使用用户栈?<br>kernel通过把用户进程的<code>Trapframe</code>的<code>tf_esp</code>设为<code>USTKTOP</code>就行了,而这个栈的物理页会有内核特别申请,映射.<br>用户的内核栈由tf_esp0指定,在JOS中,大家共享一个内核栈,或者说这是不一定的,但是具体实现的时候是指向相同的地方,每个CPU有单独的内核栈.  </p>
<figure class="highlight xl"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过这一步把用户栈设为USTACKTOP,之后esp就在这个位置往下增长</span></span><br><span class="line">	<span class="comment">//由此可以看出,esp决定了栈的位置</span></span><br><span class="line">	<span class="function"><span class="title">e</span>-&gt;</span>env_tf.tf_esp = USTACKTOP;</span><br><span class="line">	<span class="function"><span class="title">e</span>-&gt;</span>env_tf.tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// You will set e-&gt;env_tf.tf_eip later.</span></span><br></pre></td></tr></tbody></table></figure>

<p>在用户进程中,用户是怎么得到<code>envs</code>的地址的?(因为envs是定义在kernel里的,用户不能访问,而kernel把这个地方映射给了<code>UENVS</code>,用户只能访问这个<code>UENVS</code>里的envs,是怎么访问的呢?)<br>在用户的<code>entry.S</code>文件里,有这样一段:  </p>
<figure class="highlight gams"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">.data</span><br><span class="line"><span class="comment">// Define the global symbols 'envs', 'pages', 'uvpt', and 'uvpd'</span></span><br><span class="line"><span class="comment">// so that they can be used in C as if they were ordinary global arrays.</span></span><br><span class="line">	.globl envs</span><br><span class="line">	.<span class="keyword">set</span> envs, UENVS  //这个地方把<span class="comment">envs</span>的值设为<span class="comment">UENVS,</span>从此<span class="comment">,</span>用户进程访问<span class="comment">envs</span>就指向<span class="comment">UENVS,</span>而不是<span class="comment">kernel</span>里原来的<span class="comment">envs,</span>下面同理</span><br><span class="line">	.globl <span class="comment">pages</span></span><br><span class="line">	.<span class="keyword">set</span> <span class="comment">pages, UPAGES</span></span><br><span class="line">	.globl <span class="comment">uvpt</span></span><br><span class="line">	.<span class="keyword">set</span> <span class="comment">uvpt, UVPT</span></span><br><span class="line">	.globl <span class="comment">uvpd</span></span><br><span class="line">	.<span class="keyword">set</span> <span class="comment">uvpd, (UVPT+(UVPT&gt;&gt;12)*4)</span></span><br></pre></td></tr></tbody></table></figure>
<p>日志:<code>make qemu |tee -a linux.log</code>   </p>
<ul>
<li>类似于将水流发送到两个方向的三通管,<code>tee</code>命令将输出发送到终端以及文件(或作为另一个命令的输入).你可以像这样使用它:<code>command | tee file.txt</code>如果该文件不存在,它将自动创建.还可以使用 tee 命令 -a 选项进入附加模式.    </li>
<li>管道是一种通信机制,通常用于进程间的通信(也可通过socket进行网络通信),它表现出来的形式将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)<br><code>trap()</code>中incoming Trapframe的地址:<br>此时,这个是内核栈中的Trapframe,因此是内核栈中的地址:0xefffffbc 内核栈顶是:0xf0000000 相差4+4*16=68= sizeof(struct Trapframe)<br>如果用户的内核栈和内核用的栈相同,而用户的内核栈每次使用时都默认里面没有内容,从栈底开始,那么就破坏了内核的内容,该怎么办?<br>这个时候已经返回内核了,在JOS中,会继续在内核栈中执行,知道最后销毁进程,销毁之后进入<code>monitor()</code>,实际上这对内核没有什么影响,因为进入了monitor,但是之后不知道会不会有影响,我猜应该把内核用的栈和内核栈分开,当程序销毁后,再切换到内核用的栈.<br>进程从用户态进入内核态的三种方式:</li>
<li>异常</li>
<li>外围设备中断</li>
<li>系统调用<br>系统调用的三种实现方法:   </li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>net-epoll</title>
    <url>/2022/02/04/net-epoll/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>当TCP客户处理两个输入时，比如标志输入和TCP套接字，会有可能遇到由于<code>fgets()</code>被阻塞太久，服务进程被杀死的情况。<br>因此这样的进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或者多个IO条件就绪，就通知进程，这个能力叫做IO复用。<br>I/O复用典型使用在下列网络应用场合：</p>
<ul>
<li>a</li>
</ul>
<p>什么是守护进程？ inetd》》？？  </p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>select被信号中断？？<br>怎么唤醒睡眠的进程？？<br>拷贝<br>进程描述符怎么存储文件描述符</p>
<h3 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h3><p>而不是阻塞在真正的io系统调用上<br>select与多线程的区别</p>
<h3 id="信号驱动式I-O模型"><a href="#信号驱动式I-O模型" class="headerlink" title="信号驱动式I/O模型"></a>信号驱动式I/O模型</h3><p>SIGIO？ sigaction？<br>怎么通知主循环读取数据<br>多路复用的特殊性：多路</p>
<a id="more"></a>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>mit6.828 lab4</title>
    <url>/2020/12/20/mit6-828-lab4/</url>
    <content><![CDATA[<h1 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h1><p>这个实验将完成多处理器中的进程调度.<br>在partA中将:</p>
<ul>
<li>给JOS添加多处理器的支持</li>
<li>完成轮询调度</li>
<li>添加基本的进程管理系统调用(产生和销毁新进程,分配和映射内存)<br>在partB中:</li>
<li>实现一个和unix类似的<code>fork()</code>函数以允许用户进程产生一个自己的拷贝<br>在partC中:</li>
<li>实现进程间通讯以允许不同的用户进程进行交流和同步</li>
<li>实现时钟中断和优先权<a id="more"></a>

</li>
</ul>
<h1 id="PartA-multiprocessor-support-and-cooperative-multitasking"><a href="#PartA-multiprocessor-support-and-cooperative-multitasking" class="headerlink" title="PartA: multiprocessor support and cooperative multitasking"></a>PartA: multiprocessor support and cooperative multitasking</h1><ul>
<li>让系统可以跑在多处理器环境中</li>
<li>实现一个新的系统调用以允许用户进程创建新进程</li>
<li>实现协作轮询调度以允许用户进程可以资源放弃cpu,让内核切换进程</li>
</ul>
<h2 id="multiprocessor-support"><a href="#multiprocessor-support" class="headerlink" title="multiprocessor support"></a>multiprocessor support</h2><p>让JOS支持symmetric multiprocessor(SMP,对称多处理器,即地位相同).  </p>
<p><strong>excercise 1</strong><br>参照<code>boot_map_region()</code>就行,值得注意的是<code>pa</code>和<code>size</code>分别都要取整,<code>pa</code>想下取整,即从<code>pa</code>开始的那个页首开始映射,<code>size</code>向上取整,即每次映射<code>PGSIZE</code>整数倍的大小.<br>而返回值根据调用它的函数</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// lapicaddr is the physical address of the LAPIC's 4K MMIO</span></span><br><span class="line">	<span class="comment">// region.  Map it in to virtual memory so we can access it.</span></span><br><span class="line">	lapic = mmio<span class="constructor">_map_region(<span class="params">lapicaddr</span>, 4096)</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>//LAPIC: Local Application Processor Interrupt Controler<br>可以看出,返回的是映射的首地址.  </p>
<figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">	<span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">	<span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">	<span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line">	<span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line">	<span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line">	<span class="comment">// regular DRAM, you'll have to tell the CPU that it isn't</span></span><br><span class="line">	<span class="comment">// safe to cache access to this memory.  Luckily, the page</span></span><br><span class="line">	<span class="comment">// tables provide bits for this purpose; simply create the</span></span><br><span class="line">	<span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line">	<span class="comment">// write-through) in addition to PTE_W.  (If you're interested</span></span><br><span class="line">	<span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line">	<span class="comment">// 3A.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></span><br><span class="line">	<span class="comment">// handle if this reservation would overflow MMIOLIM (it's</span></span><br><span class="line">	<span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	<span class="built_in">size</span> = ROUNDUP(<span class="built_in">size</span>, PGSIZE);</span><br><span class="line">	pa = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (base + <span class="built_in">size</span> &gt;= MMIOLIM)</span><br><span class="line">	{</span><br><span class="line">		panic(<span class="string">"mmio_map_region overflow MMIOLIM!\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	boot_map_region(kern_pgdir, base, <span class="built_in">size</span>, pa, PTE_PCD | PTE_PWT | PTE_W);</span><br><span class="line">	base += <span class="built_in">size</span>;</span><br><span class="line">	<span class="comment">//panic("mmio_map_region not implemented");</span></span><br><span class="line">	<span class="comment">//返回此次映射的base</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)(base - <span class="built_in">size</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>exercise 2</strong><br>在<code>page_init()</code>里面再加个条件就行.   </p>
<figure class="highlight jboss-cli"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(<span class="attr">i</span> == 0 || <span class="attr">i</span> == (MPENTRY_PADDR / PGSIZE)</span>) </span><br><span class="line">	{</span><br><span class="line">		pages[i]<span class="string">.pp_ref</span> = 1;</span><br><span class="line">		pages[i]<span class="string">.pp_link</span> = NULL;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">Question </span><br><span class="line"></span><br><span class="line">1.Compare kern/mpentry.S side by side with boot/boot.S. Bearing <span class="keyword">in</span> mind that kern/mpentry.S is compiled <span class="keyword">and</span> linked <span class="keyword">to</span> <span class="builtin-name">run</span> above KERNBASE just like everything <span class="keyword">else</span> <span class="keyword">in</span> the kernel, what is the purpose of macro MPBOOTPHYS? Why is it necessary <span class="keyword">in</span> kern/mpentry.S but <span class="keyword">not</span> <span class="keyword">in</span> boot/boot.S? <span class="keyword">In</span> other words, what could go wrong <span class="keyword">if</span> it were omitted <span class="keyword">in</span> kern/mpentry.S?</span><br><span class="line">Hint: recall the differences between the link<span class="built_in"> address </span><span class="keyword">and</span> the load<span class="built_in"> address </span>that we have discussed <span class="keyword">in</span> Lab 1.</span><br></pre></td></tr></tbody></table></figure>
<p>答:因为对于<code>boot/boot.S</code>来说,它是运行在实模式下的,对它的寻址就是对实模式下物理地址中的寻址,因此它的寻址是对的.而对于<code>kern/mpentry.S</code>来说,这个文件的二进制代码也是和其他文件一起加载进物理内存的,并且<code>kern/mpentry.S</code>运行时,BSP开启了分页,且有了页表,此时对<code>kern/mpentry.S</code>文件里的对象寻址,得到的是<code>KERNBASE</code>上面的一个虚拟地址,而它实际上是被加载进0x7000的,如果按照原来的linker设置的地址寻址,会出问题.</p>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><p>现在我们的代码会在<code>mp_main()</code>里初始化AP后自旋/无限循环(一个for循环).在进行下一步之前,我们需要强调一下当多处理器同时运行内核代码时的竞争条件(race conditions).实现这个的最简单方式是用一个大内核锁.大内核锁是一个单独的全局锁,当有进程进入内核态时就拥有这把锁,然后在返回用户态时释放锁.在这个模型中,在用户态的进程能在多cpu上并发,但是只有一个进程能运行在内核态;任何其他想要进入内核态的进程将被强制阻塞(等待).<br>这个锁使得同时只有一个cpu处于内核态,而其他cpu想要进入内核态只能等待其他cpu退出内核态.<br>问题:为什么只能允许一个进程进入内核态?<br>如果同时有多个cpu处于内核态,它们可能会修改相关的数据和数据结构,使得cpu之间出现混乱.<br><code>kern/spinlock.h</code>声明了一个大内核锁:<code>extern struct spinlock kernel_lock;</code><br>定义在<code>kern/spinlock.c</code>:</p>
<figure class="highlight gauss"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// The big kernel lock</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">spinlock</span> kernel_lock = {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">	.name = <span class="string">"kernel_lock"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>这个锁的结构:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="comment">//互斥锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> {</span></span><br><span class="line">    <span class="comment">//如果锁被获取,locked=1,反之lock=0</span></span><br><span class="line">	<span class="keyword">unsigned</span> locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">    <span class="comment">//为了debug时能发现是谁拥有锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="comment">// For debugging:</span></span><br><span class="line">	<span class="keyword">char</span> *name;            <span class="comment">// Name of lock.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The CPU holding the lock.</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> pcs[<span class="number">10</span>];     <span class="comment">// The call stack (an array of program counters)</span></span><br><span class="line">	                       <span class="comment">// that locked the lock.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>并且提供了<code>lock_kernel()</code>和<code>unlock_kernel()</code>函数来获取和释放锁.<br>对于锁的实现需要用到一些原子指令,一个不用原子指令的获取锁的实现是:<br>Logically, xv6 should acquire a lock by executing code like</p>
<figure class="highlight basic"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">21 </span>void</span><br><span class="line"><span class="symbol">22 </span>acquire(struct spinlock *lk)</span><br><span class="line"><span class="symbol">23 </span>{</span><br><span class="line"><span class="symbol">24 </span><span class="keyword">for</span>(;;) {</span><br><span class="line"><span class="symbol">25 </span><span class="keyword">if</span>(!lk-&gt;locked) {</span><br><span class="line"><span class="symbol">26 </span>lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line"><span class="symbol">27 </span>break;</span><br><span class="line"><span class="symbol">28 </span>}</span><br><span class="line"><span class="symbol">29 </span>}</span><br><span class="line"><span class="symbol">30 </span>}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>Unfortunately, this implementation does not guarantee mutual exclusion on a multiprocessor. It could happen that two CPUs simultaneously reach line 25, see that lk-&gt;locked is zero, and then both grab the lock by executing line 26. At this point, two<br>different CPUs hold the lock, which violates the mutual exclusion property. Rather<br>than helping us avoid race conditions, this implementation of acquire has its own<br>race condition. The problem here is that lines 25 and 26 executed as separate actions.<br>In order for the routine above to be correct, lines 25 and 26 must execute in one<br>atomic (i.e., indivisible) step.    </p>
</blockquote>
<p>为了把25,26行变为一行,可以使用<code>xchgl</code>汇编指令,它原子地交换两个寄存器或者内存寄存器的内容.<br><code>xchgl</code>的原理是:x86提供了一个指令前缀<code>lock</code>(0xf0),当检测到这个前缀时,就”锁定”内存总线,知道这条指令执行完成为止.因此在执行<code>xchgl</code>时,其他处理器不能访问这个内存单元.(参考深入理解linux内核-内核同步-原子操作)<br>其他的解释:<a href="https://zhuanlan.zhihu.com/p/33445834" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33445834</a><br>JOS的实现中<code>xchg()</code>封装了<code>xchgl</code>指令:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_lock(struct spinlock *lk)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// The xchg is atomic.</span></span><br><span class="line">	<span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line">	<span class="comment">// reordered before it. </span></span><br><span class="line">	<span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">		<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"pause"</span>)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>asm volatile ("pause");</code>的作用是提高性能,参见<a href="https://c9x.me/x86/html/file_module_x86_id_232.html" target="_blank" rel="noopener">https://c9x.me/x86/html/file_module_x86_id_232.html</a><br><a href="https://kb.cnblogs.com/page/105657/" target="_blank" rel="noopener">https://kb.cnblogs.com/page/105657/</a><br><a href="http://web.cecs.pdx.edu/~alaa/courses/ece587/spring2012/notes/memory-ordering.pdf" target="_blank" rel="noopener">http://web.cecs.pdx.edu/~alaa/courses/ece587/spring2012/notes/memory-ordering.pdf</a><br>在这四个地方应该应用这个大内核锁:</p>
<blockquote>
<p>In i386_init(), acquire the lock before the BSP wakes up the other CPUs.</p>
<p>In mp_main(), acquire the lock after initializing the AP, and then call sched_yield() to start running environments on this AP.</p>
<p>In trap(), acquire the lock when trapped from user mode. To determine whether a trap happened in user mode or in kernel mode, check the low bits of the tf_cs.<br>In env_run(), release the lock right before switching to user mode. Do not do that too early or too late, otherwise you will experience races or deadlocks.</p>
</blockquote>
<blockquote>
<p>Exercise 5. Apply the big kernel lock as described above, by calling lock_kernel() and unlock_kernel() at the proper locations.   </p>
</blockquote>
<p>在对应位置加入<code>lock_kernel();</code>或者<code>unlock_kernel();</code>就行.      </p>
<blockquote>
<p>Question 2<br>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock.</p>
</blockquote>
<p>因为在<code>_alltraps</code>到<code>lock_kernel()</code>的过程中(即引发中断进入内核态时和内核上锁之间),进程已经切换到了内核态,但并没有上内核锁,此时如果有其他CPU进入内核,如果用同一个内核栈,则<code>_alltraps</code>中保存的上下文信息会被破坏(因为切换中断时,指针会重置,被压栈的数据会被覆盖(或者两个cpu使用的段可能不同)),所以即使有大内核栈,CPU也不能用用同一个内核栈.同样的,解锁也是在内核态内解锁,在解锁到真正返回用户态这段过程中,也存在上述这种情况.   </p>
<h2 id="round-robin-scheduling-轮询调度"><a href="#round-robin-scheduling-轮询调度" class="headerlink" title="round-robin scheduling(轮询调度)"></a>round-robin scheduling(轮询调度)</h2><p>轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的处理器,从1开始,直到N(内部处理个数),然后重新开始循环.<br>算法的优点是其简洁性,它无需记录当前所有连接的状态,所以它是一种无状态调度.<br>JOS的round-robin:</p>
<ul>
<li><code>kern/schec.c</code>里的<code>sched_yield()</code>函数负责挑选一个新的进程运行,因此它可以用来让出cpu.它循环线性搜索<code>envs[]</code>里的进程,对遇到的第一个<code>ENV_RUNNABLE</code>进程调用<code>env_run()</code>.</li>
<li><code>sched_yield()</code>绝对能在两个cpu上运行同一个进程.它能从进程的状态<code>ENV_RUNNABLE</code>分辨一个进程现在运行在某个cpu(可能是现在这个)</li>
<li>我们已经实现了一个系统调用<code>sys_yield()</code>,用户进程可以调用它来执行内核的<code>sched_yield()</code>,然后自动放弃cpu以运行不同的进程.</li>
<li><em>exercise 6*</em>  <blockquote>
<p>Implement round-robin scheduling in sched_yield() as described above. Don’t forget to modify syscall() to dispatch sys_yield().  </p>
</blockquote>
</li>
</ul>
<p>在<code>kern/sched.c</code>下修改：  </p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Choose a user environment to run and run it.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Search through 'envs' for an ENV_RUNNABLE environment in</span></span><br><span class="line">	<span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line">	<span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line">	<span class="comment">// running on this CPU is still ENV_RUNNING, it's okay to</span></span><br><span class="line">	<span class="comment">// choose that environment.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Never choose an environment that's currently running on</span></span><br><span class="line">	<span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line">	<span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line">	<span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (curenv!=<span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		index = ENVX(curenv-&gt;env_id);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//从0开始,因为curenv-&gt;env_status==ENV_RUNNING</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NENV; i++)</span><br><span class="line">	{</span><br><span class="line">		index += i;</span><br><span class="line">		index %= NENV;</span><br><span class="line">		<span class="keyword">if</span>(envs[index].env_status==ENV_RUNNABLE)</span><br><span class="line">		{</span><br><span class="line">			env_run(&amp;envs[index]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(curenv&amp;&amp;curenv-&gt;env_status==ENV_RUNNING)</span><br><span class="line">	{</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	}</span><br><span class="line">		<span class="comment">// sched_halt never returns</span></span><br><span class="line">		sched_halt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再在<code>kern/syscall.c</code>下dispatch<code>sched_yield()</code>：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_yield:</span><br><span class="line">		sys_yield();</span><br><span class="line">		ret= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>Question<br>3. In your implementation of env_run() you should have called lcr3(). Before and after the call to lcr3(), your code makes references (at least it should) to the variable e, the argument to env_run. Upon loading the %cr3 register, the addressing context used by the MMU is instantly changed. But a virtual address (namely e) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch?  </p>
</blockquote>
<p>在链接时，链接器把变量的虚拟地址链接到<code>KERNBASE</code>以上，在<code>bootstrap</code>时硬编码了一个页表，把初始4MB映射到<code>KERNBASE</code>开始的4MB，因此在<code>lcr3()</code>之前和之后，这个映射都是一样的。  </p>
<blockquote>
<p>4.Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?<br>这样才能恢复上下文，当任务切换回来时能正确运行。  </p>
</blockquote>
<h3 id="System-calls-for-environment-creation"><a href="#System-calls-for-environment-creation" class="headerlink" title="System calls for environment creation"></a>System calls for environment creation</h3><p>尽管内核现在可以在多个用户级别的环境中运行和切换，但仍限于内核最初设置的运行环境。现在你要实现必要的JOS系统调用，以允许用户环境创建和启动其他新的用户环境。<br>Unix提供fork()系统调用作为其过程创建原语。Unixfork()复制调用进程（父进程）的整个地址空间，以创建一个新进程（子进程）。从用户空间可观察到的两者之间的唯一区别是它们的进程ID和父进程ID（由getpid和返回getppid）。在父级中， fork()返回子级的进程ID，而在子级中，fork()返回0。默认情况下，每个进程都获得自己的专用地址空间，并且另一个进程对内存的修改对其他人都不可见。<br>你将提供一组不同的，更原始的JOS系统调用，以创建新的用户模式环境。通过这些系统调用fork()，除了创建环境的其他样式之外，你还可以完全在用户空间中实现类似Unix的功能。你将为JOS编写的新系统调用如下：<br><code>sys_exofork</code>：<br>该系统调用创建了一个几乎空白的新环境：在其地址空间的用户部分中未映射任何内容，并且该环境不可运行。<code>sys_exofork</code>调用时，新环境将具有与父环境相同的寄存器状态。在父进程中，<code>sys_exofork</code> 将返回<code>envid_t</code>新创建的环境（如果环境分配失败，则返回负错误代码）。但是，在子进程中，它将返回0。（由于子进程开始时标记为不可运行，sys_exofork因此，直到父代通过使用….标记子代可显式允许该子代之前，它 才真正返回子代。）<br><code>sys_env_set_status</code>：<br>将指定环境的状态设置为ENV_RUNNABLE或ENV_NOT_RUNNABLE。一旦其地址空间和寄存器状态已完全初始化，此系统调用通常用于标记准备运行的新环境。<br><code>sys_page_alloc</code>：<br>分配一页物理内存，并将其映射到给定环境的地址空间中的给定虚拟地址。<br><code>sys_page_map</code>：<br>将一个页面映射（而不是页面的内容！）从一个环境的地址空间复制到另一个环境，保留内存共享安排，以便新映射和旧映射都引用同一物理内存页面。<br><code>sys_page_unmap</code>：<br>取消映射在给定环境中映射到给定虚拟地址的页面。<br>对于上面所有接受环境ID的系统调用，JOS内核都支持以下约定：值0表示“当前环境”。本公约对实现envid2env() 在克恩/ env.c。</p>
<p>我们fork() 在测试程序user / dumbfork.c中提供了类Unix的非常原始的实现。该测试程序使用上述系统调用来创建和运行带有其自身地址空间副本的子环境。然后，使用sys_yield 与上一个练习相同的方法来回切换两个环境。父级在10次迭代后退出，而子级在20次迭代后退出。</p>
<p>问题:</p>
<h1 id="Call-mp-main-Exercise-for-the-reader-why-the-indirect-call"><a href="#Call-mp-main-Exercise-for-the-reader-why-the-indirect-call" class="headerlink" title="Call mp_main().  (Exercise for the reader: why the indirect call?)"></a>Call mp_main().  (Exercise for the reader: why the indirect call?)</h1><pre><code>#无页表?
movl    $mp_main, %eax
call    *%eax</code></pre><p>分页开启前是怎么寻址的?</p>
<figure class="highlight vala"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//复习实模式寻址:</span></span><br><span class="line"><span class="meta"># Each non-boot CPU ("AP") is started up in response to a STARTUP</span></span><br><span class="line"><span class="meta"># IPI from the boot CPU.  Section B.4.2 of the Multi-Processor</span></span><br><span class="line"><span class="meta"># Specification says that the AP will start in real mode with CS:IP</span></span><br><span class="line"><span class="meta"># set to XY00:0000, where XY is an 8-bit value sent with the</span></span><br><span class="line"><span class="meta"># STARTUP. Thus this code must start at a 4096-byte boundary.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="comment">//为什么?</span></span><br><span class="line"><span class="meta"># Because this code sets DS to zero, it must run from an address in</span></span><br><span class="line"><span class="meta"># the low 2^16 bytes of physical memory.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># boot_aps() (in init.c) copies this code to MPENTRY_PADDR (which</span></span><br><span class="line"><span class="meta"># satisfies the above restrictions).  Then, for each AP, it stores the</span></span><br><span class="line"><span class="meta"># address of the pre-allocated per-core stack in mpentry_kstack, sends</span></span><br><span class="line"><span class="meta"># the STARTUP IPI, and waits for this code to acknowledge that it has</span></span><br><span class="line"><span class="meta"># started (which happens in mp_main in init.c).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># This code is similar to boot/boot.S except that</span></span><br><span class="line"><span class="meta">#    - it does not need to enable A20</span></span><br><span class="line"><span class="comment">//为什么?</span></span><br><span class="line"><span class="meta">#    - it uses MPBOOTPHYS to calculate absolute addresses of its</span></span><br><span class="line"><span class="meta">#      symbols, rather than relying on the linker to fill them</span></span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>net-socket</title>
    <url>/2022/02/04/net-socket/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/u013120715/article/details/42711109" target="_blank" rel="noopener"></a><br><a href="https://blog.csdn.net/csdn_kou/article/details/81453573" target="_blank" rel="noopener">https://blog.csdn.net/csdn_kou/article/details/81453573</a><br>TCP网络编程中connect()、listen()和accept()三者之间的关系  <a href="https://tennysonsky.blog.csdn.net/article/details/45621341?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">https://tennysonsky.blog.csdn.net/article/details/45621341?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>proj-json-notes</title>
    <url>/2022/02/04/proj-json-notes/</url>
    <content><![CDATA[<h1 id="c语言写项目时注意的事项"><a href="#c语言写项目时注意的事项" class="headerlink" title="c语言写项目时注意的事项"></a>c语言写项目时注意的事项</h1><ul>
<li>宏写成 <code>do {} while(0)</code></li>
<li>这样写的原因:宏对外是表现为一个语句，但是内部可能是多个语句，为了避免这种差异产生预期外的情况,当宏后面加分号时可以不出错 <a id="more"></a>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1></li>
<li>FILE是个文件类型，不能直接当字符串用</li>
<li><code>FILE* fp=fopen("filename","r+);</code> read add and modify</li>
<li>为了避免读取空文件，应该<code>while((ch=getc(fp))!=EOF)</code>成功返回0，否则返回EOF</li>
<li>应该判断是否成功：<code>if(fclose(fp)!=0) printf("Error in closing file %s\n", argv[1]);</code>磁盘已满，磁盘被移走，I/O错误都会fclose失败</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>read-Build-an-Engine</title>
    <url>/2022/02/04/read-build-an-engine/</url>
    <content><![CDATA[<h1 id="design-our-game-engine"><a href="#design-our-game-engine" class="headerlink" title="design our game engine"></a>design our game engine</h1><p>游戏引擎一般需要这些：  </p>
<ul>
<li>Entrypoint</li>
<li>Application layer</li>
<li>Window layer<ul>
<li>Input</li>
<li>Event</li>
</ul>
</li>
<li>Renderer</li>
<li>Render API abstraction:最开始用OpenGL，简单，如果要支持多种库，需要好好设计API</li>
<li>Debugging support：logging system</li>
<li>Script language</li>
<li>Entity component system</li>
<li>file io,vfs<h1 id="project-setup"><a href="#project-setup" class="headerlink" title="project setup"></a>project setup</h1>github rep create<br>vs local project create<br>我们的目标是将引擎做成一个动态库，可以链接到目标中。不使用静态链接是因为这个时候每个使用这个引擎的游戏都需要把引擎所依赖的库链接到游戏里。而动态链接不需要游戏文件去做这个事情，引擎自己把依赖链接起来就行了。<br>在solution中再新建一个Sandbox项目 <a id="more"></a>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>design-pattern</title>
    <url>/2020/12/11/read-design-pattern/</url>
    <content><![CDATA[<h3 id="Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-read-notes"><a href="#Design-Patterns-Elements-of-Reusable-Object-Oriented-Software-read-notes" class="headerlink" title="Design Patterns: Elements of Reusable Object-Oriented Software read notes"></a><em>Design Patterns: Elements of Reusable Object-Oriented Software</em> read notes</h3><p>  设计模式使人们可以更加简单方便地复用成功的设计和体系结构，设计模式可以帮助设计者更快更好地完成系统设计。   </p>
<a id="more"></a>
<h4 id="1-5-设计模式的分类方法"><a href="#1-5-设计模式的分类方法" class="headerlink" title="1.5 设计模式的分类方法"></a>1.5 设计模式的分类方法</h4><p>可以根据两个准则对设计模式进行分类：<br>1、目的准则，即此模式是用来完成什么工作的，可分为：</p>
<ul>
<li>创建型：与对象的创建有关。</li>
<li>结构型：处理类或对象的组合。</li>
<li>行为型：对类或对象怎样交互和怎么分配职责进行描述。    </li>
</ul>
<p>2、范围准则，指定模式主要是用于类还是对象。  </p>
<ul>
<li>类模式处理类和子类之间的关系，这些关系通过继承确立，是静态的，在编译时刻便确定下来了。</li>
<li>对象模式处理对象间的关系，这些关系在运行时可以变化，更具动态性。     </li>
</ul>
<p><strong>创建型类模式</strong>将对象的部分创建工作延迟到子类，而<strong>创建型对象模式</strong>则把它延迟到另一个对象中。<br><strong>结构型类模式</strong>使用继承机制来组合类，而<strong>结构型对象模式</strong>则描述了对象的组装方式。<br><strong>行为型类模式</strong>使用继承描述算法和控制流，而<strong>行为型对象模式</strong>则描述一组对象怎样协作完成单个对象无法完成的任务。</p>
<h4 id="1-6-设计模式怎样解决设计问题"><a href="#1-6-设计模式怎样解决设计问题" class="headerlink" title="1.6 设计模式怎样解决设计问题"></a>1.6 设计模式怎样解决设计问题</h4><h4 id="Creational-Pattern"><a href="#Creational-Pattern" class="headerlink" title="Creational Pattern"></a>Creational Pattern</h4><h5 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h5><p>  工厂模式是为了解决两个问题：<br>1、父类</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>readnotes</tag>
      </tags>
  </entry>
  <entry>
    <title>read-multiplayer-game-programming</title>
    <url>/2022/02/04/read-multiplayer-game-programming/</url>
    <content><![CDATA[<h1 id="Chapter-12-游戏服务"><a href="#Chapter-12-游戏服务" class="headerlink" title="Chapter 12 游戏服务"></a>Chapter 12 游戏服务</h1><p>如今许多玩家在一些平台上都有自己的配置文件（<code>profiles</code>）,比如在<code>Steam</code>上面这些游戏服务提供了许多功能，比如比赛匹配、统计、成就、排行榜等。</p>
<a id="more"></a>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>stab解析</title>
    <url>/2020/11/29/read-stab-jie-xi/</url>
    <content><![CDATA[<h2 id="stab格式解析"><a href="#stab格式解析" class="headerlink" title="stab格式解析"></a>stab格式解析</h2><ul>
<li>阅读材料：<a href="http://wwwcdf.pd.infn.it/localdoc/stabs.pdf" target="_blank" rel="noopener">http://wwwcdf.pd.infn.it/localdoc/stabs.pdf</a>  </li>
</ul>
<h3 id="1-overview"><a href="#1-overview" class="headerlink" title="1 overview"></a>1 overview</h3><ul>
<li>stab是可执行文件中的一个部分的信息格式：This debugging information describes features of the source file like line numbers, the types and scopes of variables, and function names, parameters, and scopes.     </li>
</ul>
<a id="more"></a>

<h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4><ul>
<li>有三种不同的stab格式，由stab的第一个字区分。指令的名字决定了接下来的四种可能的数据域，并赋予他们不同的意义。这三个名字分别是：.stabs(string) .stabn(number) .stabd(dot)。而IBM的XCOFF汇编器使用.stabx(以及一些其他的数据域比如.file .bi)，而不是 .stabs .stabn .stabd。  </li>
</ul>
<p>大致的三种格式为：<br><code>.stabs "string" ,type ,other ,desc ,value</code><br><code>.stabn type, other,desc ,value</code><br><code>.stabd type, other, desc</code><br><code>.stabx "string", value, type, sdb-type</code><br>对于<code>.stabn</code>和<code>.stabd</code>来说，他们没有<code>string</code>域(<code>n_strx</code>域是0). 对于<code>.stabd</code>来说,<code>value</code>域是隐藏的，默认为当前文件位置。对于<code>.stabx</code>来说，<code>sdb-type</code>域一般不被使用并且经常被设置为0.其他域经常未被使用且被设置为0.</p>
<ul>
<li><code>type</code>域的序号代表了这个符号表的一些基本信息。每一个有效的<code>type</code>序号定义了一个不同的符号表类型，并且，<code>type</code>定义了<code>value string desc</code>等域的确切意义。  </li>
</ul>
<h4 id="1-3-string域"><a href="#1-3-string域" class="headerlink" title="1.3 string域"></a>1.3 string域</h4><ul>
<li>对于大多数的符号表，string域包含一些调试信息。这个域的灵活性使得符号表可扩展。对于某些type，string域只包含一个名字。另一些type里的string域包含更多的复杂信息。</li>
<li>大多数type的string域格式是：<ul>
<li><code>"name:symbol-descriptor type-information"</code></li>
</ul>
</li>
<li>name是符号表所代表的符号的名字。name可以省略，意味着这个stab代表一个匿名对象。比如<code>:t10=*2</code>定义了type 10 作为type 2 的指针，但是不给这个type名字。省略name域被AIX的dbx和GDB支持。</li>
<li><code>:</code>号后面的<code>symbol-descriptor</code>是一个字母符号，描述这一栏<code>stab</code>代表的<code>symbol</code>的具体类型。如果<code>symbol-descriptor</code>被省略，但是紧接着的是type信息，那这一栏<code>stab</code>代表一个局部变量。</li>
<li><code>type-information</code>格式为：<code>type-number</code>或者<code>type-number=</code>。单独的<code>type-number</code>是一个<code>type</code>引用，直接指向一个已被定义的type</li>
<li><code>type-number=</code> 格式是一个type定义，其中的<code>number</code>代表一个将被定义的新的类型。这些type定义可以通过number指向其他type，并且这些<code>type number</code>可以紧接着一个=而嵌套定义。</li>
<li>对于一个type定义，如果紧接着=号的符号不是一个数字，那么它代表一个类型描述符，并且描述了将要被定义的类型的种类。类型描述符会决定紧接着的value。</li>
</ul>
<p><a href="https://blog.csdn.net/killmice/article/details/38226983" target="_blank" rel="noopener">https://blog.csdn.net/killmice/article/details/38226983</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>xv6-read-notes</title>
    <url>/2020/10/29/read-xv6/</url>
    <content><![CDATA[<h1 id="xv6-a-simple-Unix-like-teaching-operating-system"><a href="#xv6-a-simple-Unix-like-teaching-operating-system" class="headerlink" title="xv6 a simple, Unix-like teaching operating system"></a>xv6 a simple, Unix-like teaching operating system</h1><p>简介：xv6是一个Unix version6的重新实现，v6的结构和风格、ANSI 的标准、基于x86的多进程。</p>
<h2 id="chapter-0"><a href="#chapter-0" class="headerlink" title="chapter 0"></a>chapter 0</h2><h3 id="Operating-system-interfaces"><a href="#Operating-system-interfaces" class="headerlink" title="Operating system interfaces"></a>Operating system interfaces</h3><ul>
<li><p>操作系统的工作是在多个程序之间分享计算机的资源，并提供比仅仅只有硬件更有用的服务。  </p>
</li>
<li><p>操作系统管理并抽象低层次的硬件，因此，一个字符处理器就不需要关心自己需要使用的是什么类型的储存介质。</p>
</li>
<li><p>操作系统也把硬件资源分享给多个程序使用，以便让他们（看起来）同时运行</p>
</li>
<li><p>操作系统还提供一些控制方法，以便不同的程序之间互动：分享数据、协同工作</p>
<a id="more"></a>
<h4 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h4></li>
<li><p>操作系统通过接口（interface）为用户程序提供服务</p>
</li>
<li><p>接口应该简洁、简单（narrow），但同时也应该能够支持复杂的功能特性</p>
<h4 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h4></li>
<li><p>内核是一个特殊的程序，它为各种运行的程序提供服务（支持）</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4></li>
<li><p>进程：each running program，called a process. 拥有自己的内存，内存里有：指令、数据、栈。</p>
</li>
<li><p>指令是执行程序的功能，数据是程序的操作对象，栈使得程序有序运行</p>
<h4 id="system-call"><a href="#system-call" class="headerlink" title="system call"></a>system call</h4></li>
<li><p>系统调用是操作系统提供给用户程序的功能，它的作用是在保证安全的情况下给普通用户程序执行只有内核程序才有权限执行的高级功能</p>
</li>
<li><p>流程是：当用户需要执行只有操作系统才能执行的功能时，它执行一个系统调用，这个时候程序进入内核态，执行相关功能，具体见下面总结。</p>
<h5 id="操作系统是怎么实现自己的绝对权限的："><a href="#操作系统是怎么实现自己的绝对权限的：" class="headerlink" title="操作系统是怎么实现自己的绝对权限的："></a>操作系统是怎么实现自己的绝对权限的：</h5><p>这篇知乎的帖子写得特别好：<a href="https://www.zhihu.com/question/43575404/answer/96418821?utm_source=qq&amp;utm_medium=social&amp;utm_oi=749037505906495488" target="_blank" rel="noopener">https://www.zhihu.com/question/43575404/answer/96418821?utm_source=qq&amp;utm_medium=social&amp;utm_oi=749037505906495488</a><br>我的总结：</p>
</li>
<li><p>权限是cpu制造的，即权限是对于cpu来说的：cpu现在的权限是否可以执行当前代码</p>
</li>
<li><p>用户态，内核态是对于程序自己来说的：这个程序处于用户态，处于内核态；对应于此时cpu处于低权限、高权限。</p>
</li>
<li><p>只要cpu保证权限的穿越是单向的（即代码只能把cpu权限从高设为低，而不能提高权限），就可以赋予操作系统高权限，并且保证安全：当运行操作系统进程的时候，cpu处于r0权限。当要执行用户进程的时候，操作系统主动把cpu权限降级，降到r3，于是执行用户程序代码时，cpu就在低权限了（对应于用户程序在用户态），此时cpu处于的权限无权执行高权限的功能，比如访问某些寄存器，实现的方式是：当用户执行高级功能时，cpu要比对cpu当下的权限和将要执行的功能需要的权限，如果不符，cpu就报错。而cpu处于低权限时无权把cpu权限提高。</p>
</li>
<li><p>cpu不能一直在低权限不回去，它需要提供一些特殊的接口使得cpu可以回到高权限，这就是系统调用、中断和异常。cpu返回到内核态的方式有三个：</p>
<ul>
<li>系统调用实现了这样的机制：用户态程序切换到内核态, 但是不能控制在内核态中执行的指令, 在CPU中的实现称之为陷阱指令(Trap Instruction)。用户进程通过系统调用申请高权限的功能，此时发生一个软中断，程序跳到特定地址开始执行，cpu提高权限，用户程序进入内核态，执行内核提前设置好的代码（此时体现了cpu牢牢控制在操作系统手中）。用户程序call的那条语句叫做系统调用，相应的内核内函数不叫系统调用</li>
<li>异常：cpu在低权限（用户态）执行某些代码时，发生了一些异常，会触发异常，cpu跳到提前设置好的位置执行代码（此时相当于把cpu控制权丢给操作系统），并且权限提高：比如发生缺页异常，cpu跳到相应的中断向量表指定的位置执行代码（可能会传入一些参数，比如缺的那一页的硬盘地址），把缺的页加载进内存。当异常处理完毕后，操作系统代码把cpu权限降低，再跳到用户之前执行异常的地方执行代码（相当于操作系统把权限丢给用户程序）</li>
<li>外围设备的中断：I/O设备的读写申请等</li>
<li>具体的切换操作<ul>
<li>从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：</li>
<li>[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li>
<li>[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li>
<li>[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。<br>综上：由于中断向量表等发生中断、异常、系统调用的执行程序都是操作系统设置的，只要操作系统把这几个地方处理得当，就可以完全掌控cpu而不怕被其他程序夺权。</li>
</ul>
</li>
</ul>
</li>
<li><p>而一开始操作系统的高权限是cpu开机时获得的，只要操作系统处于硬盘恰当的位置，保证第一个获取到这个权限，就可以保证控制cpu</p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>readnotes</tag>
      </tags>
  </entry>
  <entry>
    <title>read-算法导论</title>
    <url>/2022/02/04/read-suan-fa-dao-lun/</url>
    <content><![CDATA[<h1 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>无向图中的连通分量的计算<a href="https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/" target="_blank" rel="noopener">leetcode 323</a><br><a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">并查集模板</a><br>要记得初始化：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initf</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        f[i]=i;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//带路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> f[k]==k?k:f[k]=find(f[k]);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    f[find(m)]=find(n);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>链式并查集的一种表示方法是通过数组，<code>f[k]</code>表示第k个元素的所属集合（有时未更新，需要通过<code>f[k]=find(f[k])</code>更新），这个集合由集合中的一个节点表示，同一个集合的代表结点应该相同，这个代表节点很特殊，以它自己为下标的数组元素值为他自己：<code>f[head]==head</code>。<br>并查集主要是两个操作：查找和合并。查找通过递归完成：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(f[k]==k)</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">return</span> find(k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种查找在集合连接方式变成一条链时效率很低，复杂度为<code>O(n)</code>，此时可以通过路径压缩优化：在寻找代表结点时把路径上的结点的代表结点一并更新：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(f[k]==k)</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">return</span> f[k]=find(k);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>优化后可以使得后续的查询的复杂度变为<code>O(lgn)</code><br>合并比较简单，把代表结点的代表结点值设为另一个集合就行：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    f[find(m)]=find(n);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后怎么计算有多少个连通分量呢？<br>遍历所有结点，记下祖先是自己的结点。<br>或者通过set记录。  </p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p>22.2-7 职业摔跤手可以分为两种各类型：“娃娃脸”（“好人”）型和“高跟鞋”（“坏人”）型。在任意一堆职业摔跤手之间都有可能存在竞争关系。假定有 n 个职业摔跤手，并且有一个给出竞争关系的 r 对摔跤手的链表。请给出一个时间为 O( n+r ) 的算法来判断是否可以将某些摔跤手划分为“娃娃脸”型，而剩下的划分为“高跟鞋”型，使得所有的竞争关系均只存在于娃娃脸型和高跟鞋型选手之间。如果可以进行这种划分，则算法还应当生成一种这样的划分。<br>ANSWER：相当于划分成二分图。  </p>
<ol>
<li>二分图判断：给每个结点增加一个属性，定为 good（好人）或者 bad（坏人）。链表中的结点的属性必与该链表头结点属性相反。按照这个规则遍历每个链表，第一个链表表头结点属性设为 good，若在遍历过程，发现新定义的属性与先前定义的属性冲突，则不可以划分；反之，则可以划分，并且属性为 good 和 bad 的结点就是相应的两类。</li>
<li>用染色法，即从其中一个顶点开始，将跟它邻接的点染成与其不同的颜色，如果邻接的点有相同颜色的，则说明不是二分图，每次用bfs遍历即可。  <figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> color[N], graph[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//0为白色，1为黑色 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    color[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) {</span><br><span class="line">        <span class="keyword">int</span> from = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">if</span>(graph[from][i] &amp;&amp; color[i] == <span class="number">-1</span>) {</span><br><span class="line">                q.push(i);</span><br><span class="line">                color[i] = !color[from];<span class="comment">//染成不同的颜色 </span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(graph[from][i] &amp;&amp; color[from] == color[i])<span class="comment">//颜色有相同，则不是二分图 </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;     </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b, i;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span>(color));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        graph[a][b] = graph[b][a] = <span class="number">1</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(color[i] == <span class="number">-1</span> &amp;&amp; !bfs(i, n)) {<span class="comment">//遍历各个连通分支 </span></span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>




</li>
</ol>
<ul>
<li>22.2-8 我们将一棵树 T = (V, E) 的直径定义为 max (u, v∈V) δ(u, v)，也就是说，树中所有最短路径距离的最大值即为树的直径。请给出一个有效算法来计算树的直径，并分析算法的运行时间。<br>ANSWER：根据树的直径的性质：树的直径的路径的两个端点之一必定是以任一结点为源结点的最大路径的末结点。所以运行两次 BFS 搜索，第一次随机选择一个结点作为源结点；第二次选择第一次搜索结果中路径最大值的结点作为源结点，第二次 BFS 搜索得出的最大路径即为树的直径。时间复杂度为O(V+E)<br>证明：假设路径v-w为树的直径<br>1）<code>u</code>位于<code>v-w</code>所在的路径上，那么从<code>u</code>点做DFS能访问到的最远点必然是<code>v</code>或<code>w</code>, 否则假设访问到的最远点为x, 有<code>dist(u,x)≥dist(u,v)</code>，<code>dist(u,x)≥dist(u,w)</code>,分两种情况讨论：<br>a)如果只取大于号，<code>dist(u,x)&gt;dist(u,v)</code>，<code>dist(u,x)&gt;dist(u,w)</code>，那么d<code>ist(u,x)+dist(u,v)=dist(v,x)&amp;gt;dist(u,v)+dist(u,w)=dist(v,w)</code>那么v-w不是树的是直径，跟假设矛盾。<br>b)如果取大于等于号，<code>dist(u,x)≥dist(u,v)</code>，<code>dist(u,x)≥dist(u,w)</code>假设<code>dist(u,x)=dist(u,v)``dist(u,x)=dist(u,v)</code>那么<code>dist(x,w)=dist(v,w)</code>，这样也没问题，树的直径不唯一而已，那么x依然位于树的直径的一个端点上。<br>2）<code>u</code>不位于<code>v-w</code>所在的路径上，那么有<code>dist(u,x)&gt;dist(u,y,v)</code>，这里<code>y</code>是<code>u</code>到路径<code>v-w</code>的任意点，那么就有<code>dist(u,x)+dist(u,y,w)=dist(x,v)&gt;dist(u,v)+dist(u,y,w)=dist(v,w)</code>那么说明那么v-w不是树的是直径，跟假设矛盾。<br><img src="/images/loading.gif" data-original="https://i.bmp.ovh/imgs/2021/03/db18a1effaf4118d.png" alt="在最大路径上"><br><img src="/images/loading.gif" data-original="https://i.bmp.ovh/imgs/2021/03/632f2031fb5328e6.png" alt="不在最大路径上">  </li>
</ul>
<h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><h3 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h3><p>图<code>G=(V,E)</code>的转置：</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>《链接、装载与库》读书笔记</title>
    <url>/2021/03/01/read-lian-jie-zhuang-zai-yu-ku-du-shu-bi-ji/</url>
    <content><![CDATA[<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>链接器把几个输入目标文件链接成一个可执行文件。  </p>
<h4 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h4><p>当由多个目标文件链接成一个可执行文件时，会有一个问题或者说抉择：怎么将多个目标文件的各个段合并到输出文件？或者说，输出文件中的空间如何分配给输入文件？<br>一种方法是<strong>按序叠加</strong>。即依次把输入文件合并，但是这样会在多个输入文件存在时产生零散的段，会有空间浪费，因为每个段都需要一定的空间和对齐要求，会造成大量内部碎片。<br>另一种方法是<strong>相似段合并</strong>。</p>
<a id="more"></a><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>read-算法模板</title>
    <url>/2022/02/04/read-suan-fa-mo-ban/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>边的定义：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, next,w;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>用数组存储所有边:<code>int edgs[2*nums];</code>（无向边要双倍数组）<br>一个全局变量记录当前边位置<code>int cnt=-1;</code><br>添加边：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    edges[++cnt]={v, head[u],w};</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>head[u]</code>表示当前节点<code>u</code>的最新边，此节点新加入的边的<code>next</code>为此边，再把<code>head[u]</code>设为新边，因此形成一个单向链表，可以通过<code>next</code>遍历完，当遇到<code>-1</code>时结束。<br>当边存储完之后，<code>head[u]</code>存的是边<code>u</code>的头节点，可以通过这个结点遍历找到u上的边。<br><code>memset(dst,num,size);</code>把目标位置size字节的位置设为num，注意是单个字节设为num，因此如果是int，只能设为0或-1。<br>深度优先搜索：  </p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//u是到达的节点，f是其父节点，totalw是总的源节点到u的距离</span></span><br><span class="line"><span class="comment">//不应该带环，带环需要额外处理</span></span><br><span class="line"><span class="comment">//效果是找到最远点和距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f, <span class="keyword">int</span> totalw)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(totalw&gt;maxdis)</span><br><span class="line">    {</span><br><span class="line">        maxdis=totalw;</span><br><span class="line">        maxv=u;<span class="comment">//最远到达的点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//e如果是-1，则是末端节点，不用循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e=head[u];e!=<span class="number">-1</span>;e=edges[e].next)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> v=edges[e].to;<span class="comment">//e这条边指向的另一个点</span></span><br><span class="line">        <span class="comment">//如果指向父节点，则不用遍历这个点</span></span><br><span class="line">        <span class="keyword">if</span>(v==f)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//否则需要遍历</span></span><br><span class="line">        dfs(v ,u, totalw+edges[e].w);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//maxv：源点能到的最远点，maxdis:最远点对应的距离, </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> {</span> <span class="keyword">int</span> to, next, w; }edges[<span class="number">2</span> * maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], maxdis,maxv, ne; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>{</span><br><span class="line">	edges[ne] = { v, head[u], w };</span><br><span class="line">	head[u] = ne++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//u：dfs的源点，f: u点的父节点，d2s：u点到源点的距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> d2s)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (maxdis &lt; d2s){</span><br><span class="line">		maxdis = d2s;</span><br><span class="line">		maxv = u;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e != <span class="number">-1</span>; e = edges[e].next) {</span><br><span class="line">		<span class="keyword">int</span> v = edges[e].to, w = edges[e].w;</span><br><span class="line">		<span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;  <span class="comment">//父节点已经访问过，防止重复遍历，相反孩子不会重复遍历。</span></span><br><span class="line">		dfs(v, u, d2s + w);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">int</span> e, u, v, w, s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; i++) {</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">		add(u, v, w), add(v, u, w);</span><br><span class="line">	}</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//从结点1开始遍历，找到最远点maxv及对应的最远距离maxdis</span></span><br><span class="line">	maxdis = <span class="number">0</span>;</span><br><span class="line">	dfs(maxv, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//从结点maxv开始遍历，找到最远点对应的距离maxdis</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; maxdis &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>汇编学习</title>
    <url>/2020/11/04/read-hui-bian-xue-xi/</url>
    <content><![CDATA[<h3 id="对JOS-bootloader的汇编分析"><a href="#对JOS-bootloader的汇编分析" class="headerlink" title="对JOS bootloader的汇编分析"></a>对JOS bootloader的汇编分析</h3><a id="more"></a>

<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/mmu.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"># Start the CPU: <span class="keyword">switch</span> to <span class="number">32</span>-<span class="built_in">bit</span> <span class="keyword">protected</span> mode, jump into C.</span><br><span class="line"># The BIOS loads <span class="keyword">this</span> code from the first sector of the hard disk into</span><br><span class="line"><span class="meta"># memory at physical address 0x7c00 and starts executing in real mode</span></span><br><span class="line"><span class="meta"># with %cs=0 %ip=7c00.</span></span><br><span class="line"></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_CSEG, <span class="number">0x8</span>         <span class="meta"># kernel code segment selector   </span></span><br><span class="line">#此处预设代码段选择符</span><br><span class="line">#段选择符的格式： <span class="number">13</span>位索引+<span class="number">1</span>位TI表指示标志（代表是不是全局描述符）+<span class="number">2</span>位RPL</span><br><span class="line">#因此 <span class="number">0x8</span>  <span class="number">0000000000001</span> <span class="number">0</span> <span class="number">00</span></span><br><span class="line">.<span class="built_in">set</span> PROT_MODE_DSEG, <span class="number">0x10</span>        <span class="meta"># kernel data segment selector</span></span><br><span class="line">#此处预设数据段选择符</span><br><span class="line">#     <span class="number">0x10</span> <span class="number">0000000000010</span> <span class="number">0</span> <span class="number">00</span></span><br><span class="line"></span><br><span class="line">.<span class="built_in">set</span> CR0_PE_ON,      <span class="number">0x1</span>         <span class="meta"># protected mode enable flag</span></span><br><span class="line"></span><br><span class="line">#.<span class="built_in">set</span> symbol, expression设置symbol为expression。</span><br><span class="line"></span><br><span class="line">.globl start  </span><br><span class="line">start:                 #函数的开始，相当于main</span><br><span class="line">  .code16                     # Assemble <span class="keyword">for</span> <span class="number">16</span>-<span class="built_in">bit</span> mode    让汇编器按照<span class="number">16</span>位代码汇编</span><br><span class="line">  cli                         # Disable <span class="built_in">interrupts</span></span><br><span class="line">  cld                         # <span class="keyword">String</span> operations increment</span><br><span class="line">#关闭中断，设置字符串操作是递增方向</span><br><span class="line"><span class="meta">#cld的作用是将direct flag标志位清零</span></span><br><span class="line"><span class="meta">#it means that instructions that autoincrement the source index and destination index (like MOVS) will increase both of them</span></span><br><span class="line"></span><br><span class="line">  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line"></span><br><span class="line">  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  <span class="meta">#   address <span class="meta-keyword">line</span> 20 is tied low, so that addresses higher than</span></span><br><span class="line">  #   <span class="number">1</span>MB wrap around to zero by <span class="keyword">default</span>.  This code undoes <span class="keyword">this</span>.</span><br><span class="line"></span><br><span class="line">  #激活A20地址位,由于需要兼容早期pc，物理地址的第<span class="number">20</span>位绑定为<span class="number">0</span>，所以高于<span class="number">1</span>MB的地址又回到了<span class="number">0x00000</span></span><br><span class="line">  #激活A20后，就可以访问所有<span class="number">4</span>G内存，就可以使用保护模式</span><br><span class="line">  #怎么激活呢，由于历史原因A20地址位由键盘控制器芯片<span class="number">8042</span>管理。所以要给<span class="number">8042</span>发命令激活A20</span><br><span class="line">  #<span class="number">8042</span>有两个IO端口：<span class="number">0x60</span>和<span class="number">0x64</span>， 激活流程位： 发送<span class="number">0xd1</span>命令到<span class="number">0x64</span>端口 --&gt; 发送<span class="number">0xdf</span>到<span class="number">0x60</span></span><br><span class="line">seta20<span class="number">.1</span>:</span><br><span class="line">  inb     $<span class="number">0x64</span>,%al               # Wait <span class="keyword">for</span> <span class="keyword">not</span> busy</span><br><span class="line">  #汇编语言有专门的读取端口信息的指令，in out后面的b代表一个字节</span><br><span class="line">  testb   $<span class="number">0x2</span>,%al</span><br><span class="line">  #测试（两操作数作与运算,仅修改标志位，不回送结果）。</span><br><span class="line">  jnz     seta20<span class="number">.1</span></span><br><span class="line">#发送命令之前，要等待键盘输入缓冲区为空，这通过<span class="number">8042</span>的状态寄存器的第<span class="number">2b</span>it来观察，而状态寄存器的值可以读<span class="number">0x64</span>端口得到。</span><br><span class="line">#上面的指令的意思就是，如果状态寄存器的第<span class="number">2</span>位为<span class="number">1</span>，就跳到seta20<span class="number">.1</span>符号处执行，知道第<span class="number">2</span>位为<span class="number">0</span>，代表缓冲区为空</span><br><span class="line"></span><br><span class="line">  movb    $<span class="number">0xd1</span>,%al               # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></span><br><span class="line">  outb    %al,$<span class="number">0x64</span></span><br><span class="line">#发送<span class="number">0xd1</span>到<span class="number">0x64</span>端口</span><br><span class="line">seta20<span class="number">.2</span>:</span><br><span class="line">  inb     $<span class="number">0x64</span>,%al               # Wait <span class="keyword">for</span> <span class="keyword">not</span> busy</span><br><span class="line">  testb   $<span class="number">0x2</span>,%al</span><br><span class="line">  jnz     seta20<span class="number">.2</span></span><br><span class="line"></span><br><span class="line">  movb    $<span class="number">0xdf</span>,%al               # <span class="number">0xdf</span> -&gt; port <span class="number">0x60</span></span><br><span class="line">  outb    %al,$<span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">  # Switch from real to <span class="keyword">protected</span> mode, <span class="keyword">using</span> a bootstrap GDT</span><br><span class="line">  <span class="meta"># and segment translation that makes virtual addresses </span></span><br><span class="line">  <span class="meta"># identical to their physical addresses, so that the </span></span><br><span class="line">  <span class="meta"># effective memory map does not change during the switch.</span></span><br><span class="line">  #转入保护模式，这里需要指定一个临时的GDT，来翻译逻辑地址。</span><br><span class="line">  #这里使用的GDT通过gdtdesc段定义，它翻译得到的物理地址和虚拟地址相同（段描述符里的段基址为<span class="number">0</span>）</span><br><span class="line">  #所以转换过程中内存映射不会改变</span><br><span class="line">  lgdt    gdtdesc   </span><br><span class="line">  <span class="meta">#lgdt指令把gdtdesc的地址加载进gdtr寄存器，代表全局段描述符表</span></span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  #开启保护模式</span><br><span class="line">  # Jump to next instruction, but in <span class="number">32</span>-<span class="built_in">bit</span> code segment.</span><br><span class="line">  # Switches processor into <span class="number">32</span>-<span class="built_in">bit</span> mode.</span><br><span class="line">  #由于进入保护模式，所有地址都应该是：cs:eip</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg         <span class="meta">#ljmp cs esp</span></span><br><span class="line">  #Long jump, use <span class="number">0xfebc</span> <span class="keyword">for</span> the CS <span class="keyword">register</span> <span class="keyword">and</span> <span class="number">0x12345678</span> <span class="keyword">for</span> the EIP <span class="keyword">register</span>:</span><br><span class="line">  <span class="meta">#ljmp $0xfebc, $0x12345678</span></span><br><span class="line"></span><br><span class="line">  .code32                     # Assemble <span class="keyword">for</span> <span class="number">32</span>-<span class="built_in">bit</span> mode</span><br><span class="line">protcseg:</span><br><span class="line">  # Set up the <span class="keyword">protected</span>-mode data segment registers</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line">  </span><br><span class="line">  # Set up the <span class="built_in">stack</span> pointer <span class="keyword">and</span> call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn't), loop.</span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align <span class="number">2</span>                                <span class="meta"># force 4 byte alignment</span></span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL				<span class="meta"># null seg</span></span><br><span class="line">  SEG(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)	<span class="meta"># code seg</span></span><br><span class="line">  SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)	        <span class="meta"># data seg</span></span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .<span class="keyword">word</span>   <span class="number">0x17</span>                            <span class="meta"># sizeof(gdt) - 1</span></span><br><span class="line">  .<span class="keyword">long</span>   gdt                             <span class="meta"># address gdt</span></span><br></pre></td></tr></tbody></table></figure>

<p><a href="https://www.cnblogs.com/maruixin/p/3175894.html" target="_blank" rel="noopener">https://www.cnblogs.com/maruixin/p/3175894.html</a><br><a href="https://blog.csdn.net/suz_cheney/article/details/24198003?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">https://blog.csdn.net/suz_cheney/article/details/24198003?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a><br><a href="https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-73/index.html" target="_blank" rel="noopener">https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-73/index.html</a>    </p>
<ul>
<li>寻址方式(找数据的方式):立即数 直接寻址 间接寻址<ul>
<li>立即数寻址:数据在指令中,立即可以得到数据</li>
<li>寄存器寻址:数据在寄存器中,直接写寄存器的名字</li>
<li>存储器寻址:数据在存储器中,表示出数据在存储器中的地址</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2022/02/04/vim/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/ifreewolf_csdn/article/details/83175832" target="_blank" rel="noopener">https://blog.csdn.net/ifreewolf_csdn/article/details/83175832</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>递归转循环</title>
    <url>/2020/11/02/di-gui-zhuan-xun-huan/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>信息安全概论</title>
    <url>/2022/02/04/xin-xi-an-quan-gai-lun/</url>
    <content><![CDATA[<h1 id="class-1"><a href="#class-1" class="headerlink" title="class 1"></a>class 1</h1><figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">信息安全发展历史:  </span><br><span class="line"><span class="number">1.</span>计算机安全(computer security):<span class="number">60</span>年代中期至<span class="number">80</span>年代中期,机密性、访问控制与认证.</span><br><span class="line"><span class="number">20</span>世纪<span class="number">60</span>年代中期至<span class="number">80</span>年代中期。</span><br><span class="line">    <span class="number">20</span>世纪<span class="number">60</span>年代出现了多用户操作系统，由于需要解决安全共享问题，人们对信息安全的关注扩大为“机密性、访问控制与认证”，但逐渐注意到可用性。</span><br><span class="line">    美国国防部的一篇文章Rand Report R<span class="number">-609</span>提出，除了软硬件物理位置的保护之外，还应定义多个控制机制，来保护多层次的计算机系统。该文档保密了大约<span class="number">10</span>年，现在称为“计算机安全研究的起点”。</span><br><span class="line">    Rand Report R<span class="number">-609</span> 第一次确定计算机安全中的管理角色和方针问题。它指出，信息系统中的联网组件在军队中得到广泛使用，由此带来的复杂性已超出了用于保护这些系统的常规措施。这篇文章标志着计算机安全史上一个关键时刻的到来——计算机安全的范围被大大地扩展了，除了物理位置和硬件的安全之外还包括：</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">        数据的安全</span><br><span class="line">        限制对数据的随机访问和未授权访问</span><br><span class="line">        涉及到机构内多个层次的人员</span><br><span class="line">Anderson最早提出了入侵检测系统IDS的概念，这标志着人们已经关注利用技术手段获得可用性。            </span><br><span class="line">美国国家标准与技术研究所（NIST）于<span class="number">1977</span>年首次通过 “数据加密标准DES。 </span><br><span class="line"><span class="number">1978</span>年，Rivest、Shamir与Adleman设计了著名的RSA公钥密码算法。  </span><br><span class="line">对计算机安全的研究主要集中于一个称为MULTICS（Multiplexed Information <span class="keyword">and</span> Computing Service, 多元信息和计算服务）的系统上。这个操作系统已废弃，但是它仍值得关注，因为它是第一个、也是唯一一个以安全为目标创建的操作系统。它是一个大型分时操作系统，<span class="number">20</span>世纪<span class="number">60</span>年代中叶由通用电气公司（GE）、贝尔实验室和麻省理工学院（MIT）联合开发而成。<span class="number">1969</span>年中期，在MUTICS项目重构不久，它的几个重要参与者Ken Thompson、Dennis Ritchie、Rudd Canaday 和Doug McIlroy创建了一个新型操作系统UNIX。当时MULTICS系统实现了多安全级别和密码，而UNIX系统没有。UNIX的基本意图是文字处理，并不需要与其原型具有一样的安全级别。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>IT安全(IT security)</span><br><span class="line">         <span class="number">20</span>世纪<span class="number">80</span>年代中期至<span class="number">90</span>年代中期</span><br><span class="line">             <span class="number">6</span>个基本属性。</span><br><span class="line">保密性—Confidentiality</span><br><span class="line">完整性—Integrity</span><br><span class="line">可用性—Availability</span><br><span class="line">可控性—Controllability</span><br><span class="line">不可否认性—Non-repudiation</span><br><span class="line">真实性—Authenticity </span><br><span class="line">            学术界和产业界先后提出了基于网络的入侵检测IDS、分布式入侵检测IDS、防火墙（Firewall）等网络统防护技术。</span><br><span class="line"><span class="number">20</span>世纪<span class="number">80</span>年代开始，由于互联网技术的飞速发展，信息无论是对内还是对外都得到极大开放，由此产生的信息安全问题跨越了时间和空间，信息安全的焦点已经不仅仅是传统的保密性、完整性和可用性三个原则了，由此衍生出了诸如可控性、抗抵赖性、真实性等其他的原则和目标，信息安全也转化为从整体角度考虑其体系建设的信息保障（Information Assurance）阶段。</span><br><span class="line"><span class="number">3.</span>信息安全保障(information assuraance)</span><br><span class="line">信息安全保障</span><br><span class="line">在美国称之为信息保障IA（Information Assurance）。<span class="number">1996</span>年美国国防部(DoD)在国防部令S<span class="number">-3600.1</span>对信息保障下作了如下定义：保护和防御信息及信息系统，确保其可用性，完整性，保密性，可认证性，不可否认性等特性。这包括在信息系统中融入保护，检测，反应功能，并提供信息系统的恢复功能。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">信息安全是研究在特定的应用环境下，依据特定的安全策略，对信息及其系统实施防护、检测和恢复的科学。</span><br><span class="line">这里安全策略表示人们在特定应用环境下对信息安全的要求。</span><br><span class="line">该定义明确了信息安全的保护对象、保护目标和方法</span><br><span class="line">不同的安全策略表现为不同的安全目标的集合。安全目标通常被描述为“允许谁怎样使用系统中的哪种资源”、“不允许谁怎样使用系统中的哪种资源”或事务实现中各“参与者的行为规则是什么”等。</span><br><span class="line"></span><br><span class="line">安全目标分类：</span><br><span class="line">数据安全、事务安全、系统安全（包括网络系统与计算机系统安全）三类。</span><br><span class="line"></span><br><span class="line">数据安全主要涉及数据的机密性与完整性；</span><br><span class="line">事务安全主要涉及身份识别、抗抵赖等多方计算安全；</span><br><span class="line">系统安全主要涉及身份识别、访问控制、可用性。</span><br><span class="line"></span><br><span class="line">机密性（confidentiality）</span><br><span class="line">确保计算机的相关资源仅被合法用户访问</span><br><span class="line">完整性（<span class="built_in">int</span>egrity）</span><br><span class="line">所有资源只能由授权方或以授权的方式进行修改能够保障被传输、接收或存储的数据是未被篡改、未被破坏、未被插入、未延迟、未乱序和未丢失的，在被篡改的情况下能够发现篡改的事实或者篡改的位置。防篡改</span><br><span class="line"></span><br><span class="line">可用性（availability）</span><br><span class="line">所有资源在适当的时候可以由被授权方访问</span><br><span class="line"></span><br><span class="line">      安全策略中的安全目标通过一些方法、工具和过程来实现，这些方法称为安全机制。</span><br><span class="line">      安全机制分类：防护、检测、恢复</span><br><span class="line">防护机制包括密码技术（指加密、身份识别、消息鉴别、数字签名）、访问控制技术、通信量填充、路由控制、信息隐藏技术等；</span><br><span class="line">检测机制则包括审计、验证技术、入侵检测、漏洞扫描等；</span><br><span class="line">恢复机制包括状态恢复、数据恢复等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">事务满足的ACID性质 </span><br><span class="line"></span><br><span class="line">原子性（atomicity）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一致性（consistency）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">孤立性（isolation）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">持续性（durability）</span><br><span class="line"></span><br><span class="line">合谋攻击中的攻击者可能是事务的参与方，也可能不是，买通事务的若干参与方共同欺骗其余的参与方，以获得非法权限或利益。</span><br><span class="line">选择明文攻击、选择密文攻击、预言者会话、并行会话攻击等。</span><br><span class="line">事务安全被破坏:</span><br><span class="line">使用了参与方在身份识别的缺陷。</span><br><span class="line">使用了参与方在抗抵赖方面的缺陷。</span><br><span class="line">更一般地，攻击者利用了多方计算协议的设计或实现漏洞。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">机密性</span><br><span class="line">完整性</span><br><span class="line">身份识别</span><br><span class="line">访问控制</span><br><span class="line">抗抵赖</span><br><span class="line">可用性</span><br><span class="line"></span><br><span class="line">保密性：防泄密,能够确保敏感或机密数据的传输和存储不遭受非授权的个人和实体的浏览或使用，甚至可以做到不暴露保密通信的事实。</span><br><span class="line">完整性：防篡改,能够保障被传输、接收或存储的数据是未被篡改、未被破坏、未被插入、未延迟、未乱序和未丢失的，在被篡改的情况下能够发现篡改的事实或者篡改的位置。</span><br><span class="line">可用性：放中断,可用性是指信息可被合法用户访问并能按要求顺序使用的特性，即在需要时就可以取用所需的信息。 </span><br><span class="line">可控性：防抵赖,能够保证掌握和控制信息与信息系统的基本情况，可对信息和信息系统的使用实施可靠的授权、审计、责任认定、传播源追踪和监管等控制。</span><br><span class="line">非否认性：能够保证信息系统的操作者或信息的处理者不能否认其行为或者处理结果，这可以防止参与某次操作或通信的一方事后否认该事件曾发生过。非否认性可以防止抵赖，交易中非常重要的环节。如电子商务中电子合同和电子邮件。</span><br><span class="line">真实性：防诈骗,真实性也称可认证性，能够确保实体（如人、进程或系统）身份或信息、信息来源的真实性，特别是身份识别。</span><br><span class="line"></span><br><span class="line">这六种安全目标已经基本上覆盖了现有的攻击。但应当说明的是六种安全目标绝对没有覆盖未来发现的攻击行为。这一点同其他学科不大一样，因为攻、防本身是在不断变化发展的 </span><br><span class="line"></span><br><span class="line">信息安全层次:信息安全 数据与事务安全 计算机与网络安全 人事安全</span><br></pre></td></tr></tbody></table></figure>
<h1 id="class-2"><a href="#class-2" class="headerlink" title="class 2"></a>class 2</h1><table>
<thead>
<tr>
<th>OSI</th>
<th>安全机制</th>
<th>安全服务</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>加密</td>
<td>鉴别服务</td>
</tr>
<tr>
<td>表示层</td>
<td>数字签名</td>
<td>访问控制</td>
</tr>
<tr>
<td>会话层</td>
<td>访问控制</td>
<td>数据完整性</td>
</tr>
<tr>
<td>传输层</td>
<td>数据完整性</td>
<td>数据保密性</td>
</tr>
<tr>
<td>网络层</td>
<td>鉴别交换</td>
<td>抗抵赖</td>
</tr>
<tr>
<td>数据链路层</td>
<td>业务流程填充</td>
<td></td>
</tr>
<tr>
<td>物理层</td>
<td>路由控制</td>
<td></td>
</tr>
<tr>
<td></td>
<td>公证</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>TCP/IP模型</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
</tr>
<tr>
<td>网络接口层</td>
</tr>
</tbody></table>
<p>应用层：直接为用户的应用进程提供服务，对应用进程经常使用的一些功能以及实现这些功能所要使用的协议标准化。Internet的主要应用有：www、电子邮件、远程登录、文件传输等。<br>表示层：主要解决所传输的数据的语法表示。用于数据格式的转化、加密、解密以及压缩等。<br>会话层：提供在两个通信的应用进程之间建立、维持和同步其交互。对数据传输进行管理，但不参与具体的数据传输<br>传输层：提供端到端的通信，实现透明的报文段传输。报文段是传输层的协议数据单元<br>网络层：确定分组从源端到目的端的路由，负责将源端发出的分组按照路由规则传送到目的端，实现主机到主机的传输。网络层还负责解决网际互联的问题，实现分组跨越多个通信子网的传输。分组是网络层的协议数据单元<br>数据链路层：提供在两个相邻节点间无差错的传输数据帧。将一条有可能出差错的信道转变为几乎无差错的数据链路，实现可靠传输。帧是数据链路层的协议数据单元<br>物理层：物理层提供在物理介质上透明的传输比特流所需的各种功能。定义了接口和传输介质的机械和电气规范，以及物理设备和接口在传输时必须执行的过程和功能</p>
<p>第一章 信息安全基本概念<br>信息安全基本问题：信息篡改<br>信息安全的目标：事务安全 数据安全 系统安全(网络系统与计算机系统)<br>计算机系统中的安全威胁:假冒攻击(分为重放,伪造和代替),旁路攻击,非授权访问,拒绝服务攻击,恶意程序<br>网络系统中的安全威胁:截获修改,插入重做,服务欺骗,窃听和数据分析,网络拒绝服务<br>事务安全威胁:字典攻击(猜口令),中间人攻击,合谋攻击,选择明文攻击,选择密文攻击</p>
<p>第二章</p>
<p>第四章 DES(数据加密标准)<br>AES DES基本概念:<br>DES的攻击类型:穷举攻击(目前最有效) 差分攻击 线性攻击<br>DES的安全弱点:密钥太短 存在弱密钥 存在对称互补性<br>3DES长度更长,使用三次加密:112 168  密钥长度<br>分组密码：明文长度128，密文长度、密钥长度可变(128/192/256等，现在一般取128)。<br>面对二进制的密码算法：能够加解密任何形式的计算机数据。<br>不是对合运算：加、解密使用不同的算法。<br>综合运用了置换、代替、代数等多种密码技术<br>整体结构：基本轮函数加迭代。圈数可变，≥𝟏𝟎<br>基本变换包括SubBytes（字节替代）、ShiftRows（行移位）、MixColumns（列混淆）、AddRoundKey(轮密钥加）<br>最后一圈中的圈变换中没有列混合变换。<br>S盒变换是AES的唯一的非线性变换，是AES安全的关键。<br>AES使用16个相同的S盒，DES使用8个不相同的S盒。<br>AES的S盒有8位输入8位输出，DES的S盒有6位输入4位输出。<br>S盒变换的第一步是把字节的值用它的乘法逆来代替，是一种非线性变换。<br>由于系数矩阵中每列都含有5个1，这说明改变输入中的任意一位，将影响输出中的5位发生变化。<br>由于系数矩阵中每行都含有5个1，这说明输出中的每一位，都与输入中的5位相关。<br>行移位变换对状态的行进行循环移位。<br>第0行不移位，第1行移𝑪𝟏字节，第2行移𝑪𝟐字节，第3行移𝑪𝟑字节。<br>C1，C2，C3按表取值<br>行移位变换属于置换，本质在于把数据打乱重排。<br>AES的行移位变换属于线性变换。<br>列混合变换属于代替变换。</p>
<p>算法可逆是对加密算法的基本要求。<br>AES的加密算法不是对合运算：解密算法和加密算法不同。<br>AES的巧妙之处：虽然解密算法与加密算法不同，但是解密算法与加密算法的结构相同。<br>把加密算法的基本变换变为逆变换，便得到解密算法。<br>能够抵抗目前所有的已知攻击：<br>穷举攻击。<br>差分攻击。<br>线性攻击<br>𝑆𝑞𝑢𝑎𝑟𝑒攻击</p>
<p>第五章 AES(高级数据加密标准)<br>AES涉及要求:可抵抗目前已知所有攻击 分组长度和密钥长度可扩展 速度快适应各种环境<br>第六章 RSA<br>强力穷举密钥<br>数学攻击 ：实质上是对两个素数乘积的分解<br>时间攻击：依赖解密算法的运行时间<br>分解 𝑁=𝑝.𝑞, 因此可计算出Φ(𝑁)，从而确定𝑑<br>直接确定Φ(𝑁)，然后找到𝑑<br>直接确定𝑑</p>
<p>第七章 哈希函数与数字签名<br>密码技术不仅提供机密性服务,还提供数据完整性服务,hash函数就是能提供完整性保证的一个工具.<br>计算hash,与数据同时传递,再次算hash,比较是否相同.关键在于,不可伪造hash,知道hash值和函数不能还原原文,知道hash值和函数不能找到相同的原文使得hash相同,不能找到碰撞.<br>hash值叫消息摘要也叫指纹,可以用于鉴别.<br>鉴别的目的:验证信息的发送者是真正的不是冒充的,同时发送者也不可以抵赖(由秘密只有发送者知道保证);验证消息的完整性(由hash码不可还原和碰撞保证),未被篡改重放或延迟.<br>实际应用中，消息认证通常使用消息认证码（MAC）实现。MAC函数将通信双方共享的密钥和数据块作为输入，产生Hash值作为MAC码，然后将MAC码和受保护的消息一起传递或存储。需要检查消息的完整性时，使用MAC函数对消息重新计算，并将计算结果与存储的MAC码对比。MAC提供安全保护，用于抵抗不知道密钥的攻击者的攻击。在实现中，往往使用比加密算法效率更高的特殊设计的MAC函数。<br>hash函数的三个问题的基本概念:原像问题:知道y和h,找出x; 第二原像问题:知道y和h找出一个x’!=x使得h(x’)=y;碰撞问题:已知h,找到h(x)=h(x’),x!=x’;</p>
<p>对Hash函数的攻击</p>
<p>　　1、穷举攻击</p>
<p>　　a) 原像攻击和第二原像攻击</p>
<p>　　攻击者对给定的Hash值h，试图找到满足H(y) = h的y。穷举攻击的方法是随机选择y，尝试计算其Hash值知道碰撞出现。对于m位的Hash值，穷举的规模大约是2m,对于攻击者平均尝试次数为2m-1，才能找到一个满足H(y)=h的y值。</p>
<p>　　b) 碰撞攻击</p>
<p>　　对于碰撞攻击，攻击者试图找到两个消息或数据块x和y，满足H(x)=H(y)，与原像攻击和第二原像攻击相比，其穷举的规模相对更小一些，这也通过数学上的生日悖论得到印证。本质上，如果我们在均匀分布的0到N-1的范围内选择随机整数变量，那么在N1/2次选择后发生重复的概率就会超过0.5。因此，对于m位的Hash值，如果我们随机选择数据块，预计在2m/2次尝试后就能找到两个具有相同Hash值的数据块。</p>
<p>　　Yuval提出以下策略进行碰撞攻击：</p>
<p>　　　　1、发送方A准备对文本消息x进行签名（尚未签名，但可预期要签名的文件内容），其使用的方法是：用A的私钥对m位的Hash码加密并将加密后的Hash码附于消息之后。</p>
<p>　　　　2、攻击者产生该消息x的2m/2种变式x’，每种变式都表达相同的意义，将这些消息以及对应的Hash值存储起来。</p>
<p>　　　　　　产生多个具有相同意义的变式并不难，例如攻击者可以在文件的词与词之间插入若干“空格-空格-退格”字符对，然后在实例中用“空格-退格-空格”替代这些字符，从而产生各种变式。攻击者也可以简单地改变消息中的某些词但不改变消息的意义。</p>
<p>　　　　3、攻击者准备伪造一条消息y，并想获取A的签名，只需要伪造y的变式y’,然后计算H(y’)，并与所有的H(x’)进行比对，直到碰撞出现。</p>
<p>　　　　4、攻击者将发生碰撞的消息x’提供给A签名，然后将该签名附于伪造消息y’后。这样攻击者就在不知道A密钥的情况下获得了有A数字签名的消息y’，并可以此获利。</p>
<p>　　2、密码分析</p>
<p>　　对Hash函数的密码分析攻击，也是利用算法的某种性质而不是通过穷举来进行攻击的。理想的Hash函数算法要求密码分析攻击所需的代价大于或等于穷举攻击所需的代价。</p>
<p>　　</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Etymology</title>
    <url>/2022/02/05/etymology/</url>
    <content><![CDATA[<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
</search>
