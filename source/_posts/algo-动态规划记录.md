# 动态规划

## 区间dp
区间dp就是二维数组来限定区间，i-j这个区间由`dp[i][j]`来表示，i-j区间的答案由i-j之间更小区间决定，此时更小区间往往已经求得。有时解题关键在于分割，或者界限所在。  
leetcode 664.奇怪的打印机：https://leetcode-cn.com/problems/strange-printer/  
这里的特殊的是首位字符的打印，它的特殊在于：它最多被打印一次，第二次打印是多余的，而不像其他位置，可以通过覆盖产生，而不会是多余的打印。  
第一个字符的打印次序也很特殊，它可以总是被第一个打印：否则，把打印第一个字符的那次打印操作移到第一次进行，可以得到一个次数不会增加的操作序列，结果不变。  
操作的构造：
* 假设打印首位字符的是第k次操作，这次操作打印n个字符，把这次打印移到第一次进行，设这n个字符最后被保留x个被覆盖y个
* 覆盖的y个字符由于在k次操作之后的操作被覆盖，因此k次之后的操作序列不变，这部分结果也不变
* 被保留的x个字符，由于把k次操作以前的字符都覆盖了，因此k次操作之前的字符打印是多余的，除去这部分操作，这部分操作不涉及到前n个字符，则操作次数不会变多  

//贪心：总是从区间的第一个字符开始打印，且字符序列长度为区间长度，然后以被保留的此字符为分界线分割更小的区块，在这基础上打印。错误！！！！  
//错误！！：因此，打印策略为：从首位字符开始打印，第一次打印覆盖所有位置，再以此为分割分成小块，同样按照这样的策略打印。  
`dp[i][j]`表示`i`到`j`这段字符的打印最少次数，实际上`dp[i][j]`最小值要么是`dp[i][j-1]`（不能比这小），要么是`dp[i][j-1]+1`：假设`dp[i][j]`比`dp[i][j-1]`小，则存在一个打印方案，把`dp[i][j]`打印出来，此时只需要在打印`j`的那次操作少打印一个字符，便可以打印出`dp[i][j-1]`,次数更少，矛盾。而如果打印方案不是`dp[i][j-1]`，则在`dp[i][j-1]`基础上再打印最后一个字符便可以得到`dp[i][j]`，因此次数最多+1。同理`dp[i][j]`不能比`dp[i+1][j]`小。
合并两个区间的关键在于分界线，如果最优打印存在一个分界线，分界线两边的打印总是不会跨过这条线，则大区间的最优打印次数等于两边小区间的最优次数之和。  
而如果一条线的两边没有相同的字符，比如左边有a右边没有a，则打印a的这次操作没有必要跨过这条分界线，意味着，如果首尾的字符不同，则一定存在这样的最优分界线。这个时候去遍历这条最优分界线就行了。    
进一步，这条分界线一定在与`s[i]`字符相同的一个地方，否则分界线还可以更多。  
而如果首尾字符相同，则可以把打印第一个字符和最后一个字符的操作连在一起，移到第一次打印，则`dp[i][j]=dp[i][j-1]`  
并且相邻的两个dp最多只相差1，因为相邻的两个总是可以互相从另一个多打印一次得到。 
因此`min(dp[i][j-1],dp[i+1][j])+1>=dp[i][j]>=min(dp[i][j-1],dp[i+1][j])`，或者`max(dp[i][j-1],dp[i+1][j])+1>=dp[i][j]>=max(dp[i][j-1],dp[i+1][j])`，是一样的。实际上只要相邻两个dp数值不同，则取大的那个就行了；如果数值相同，则需要判断，如果首尾相同的话，则可以省去一次打印，可以取最小值。 
```cpp
class Solution
{
public:
    int strangePrinter(string s)
    {
        if (s.size() < 1)
            return 0;
       int dp[s.size()][s.size()];
        for (int i = 0; i < s.size(); i++)
        {
            dp[i][i] = 1;
        }
        for (int i = 1; i < s.size(); i++)
        {
            for (int j = 0; j < s.size() - i; j++)
            {
                
                    if(s[j]==s[i+j])
                    {
                        dp[j][i + j] = dp[j][i + j - 1];
                        continue;
                    }
                    dp[j][i + j] = dp[j][i + j - 1] + 1;
                    for (int n = j ; n < i + j;n++)
                    {
                        if(s[j]==s[n])
                        dp[j][i + j] = min(dp[j][i + j],dp[j][n] + dp[n+1][j+i]);
                    }
            }
            }
        return dp[0][s.size() - 1];
    }
};
``` 
 
