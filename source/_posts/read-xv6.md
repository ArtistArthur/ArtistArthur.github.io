---
title: xv6-read-notes
top: false
cover: false
toc: true
mathjax: true
date: 2020-10-29 21:33:33
password:
summary:
tags: [OS,readnotes]
categories: OS
---

# xv6 a simple, Unix-like teaching operating system  
简介：xv6是一个Unix version6的重新实现，v6的结构和风格、ANSI 的标准、基于x86的多进程。
## chapter 0  
### Operating system interfaces  
* 操作系统的工作是在多个程序之间分享计算机的资源，并提供比仅仅只有硬件更有用的服务。  
* 操作系统管理并抽象低层次的硬件，因此，一个字符处理器就不需要关心自己需要使用的是什么类型的储存介质。
* 操作系统也把硬件资源分享给多个程序使用，以便让他们（看起来）同时运行
* 操作系统还提供一些控制方法，以便不同的程序之间互动：分享数据、协同工作
<!--more-->
#### interface
* 操作系统通过接口（interface）为用户程序提供服务
* 接口应该简洁、简单（narrow），但同时也应该能够支持复杂的功能特性
#### kernel
* 内核是一个特殊的程序，它为各种运行的程序提供服务（支持）
#### process
* 进程：each running program，called a process. 拥有自己的内存，内存里有：指令、数据、栈。
* 指令是执行程序的功能，数据是程序的操作对象，栈使得程序有序运行
#### system call
* 系统调用是操作系统提供给用户程序的功能，它的作用是在保证安全的情况下给普通用户程序执行只有内核程序才有权限执行的高级功能
* 流程是：当用户需要执行只有操作系统才能执行的功能时，它执行一个系统调用，这个时候程序进入内核态，执行相关功能，具体见下面总结。
##### 操作系统是怎么实现自己的绝对权限的：
这篇知乎的帖子写得特别好：https://www.zhihu.com/question/43575404/answer/96418821?utm_source=qq&utm_medium=social&utm_oi=749037505906495488
我的总结：
* 权限是cpu制造的，即权限是对于cpu来说的：cpu现在的权限是否可以执行当前代码
* 用户态，内核态是对于程序自己来说的：这个程序处于用户态，处于内核态；对应于此时cpu处于低权限、高权限。

* 只要cpu保证权限的穿越是单向的（即代码只能把cpu权限从高设为低，而不能提高权限），就可以赋予操作系统高权限，并且保证安全：当运行操作系统进程的时候，cpu处于r0权限。当要执行用户进程的时候，操作系统主动把cpu权限降级，降到r3，于是执行用户程序代码时，cpu就在低权限了（对应于用户程序在用户态），此时cpu处于的权限无权执行高权限的功能，比如访问某些寄存器，实现的方式是：当用户执行高级功能时，cpu要比对cpu当下的权限和将要执行的功能需要的权限，如果不符，cpu就报错。而cpu处于低权限时无权把cpu权限提高。
* cpu不能一直在低权限不回去，它需要提供一些特殊的接口使得cpu可以回到高权限，这就是系统调用、中断和异常。cpu返回到内核态的方式有三个：
   * 系统调用实现了这样的机制：用户态程序切换到内核态, 但是不能控制在内核态中执行的指令, 在CPU中的实现称之为陷阱指令(Trap Instruction)。用户进程通过系统调用申请高权限的功能，此时发生一个软中断，程序跳到特定地址开始执行，cpu提高权限，用户程序进入内核态，执行内核提前设置好的代码（此时体现了cpu牢牢控制在操作系统手中）。用户程序call的那条语句叫做系统调用，相应的内核内函数不叫系统调用
   * 异常：cpu在低权限（用户态）执行某些代码时，发生了一些异常，会触发异常，cpu跳到提前设置好的位置执行代码（此时相当于把cpu控制权丢给操作系统），并且权限提高：比如发生缺页异常，cpu跳到相应的中断向量表指定的位置执行代码（可能会传入一些参数，比如缺的那一页的硬盘地址），把缺的页加载进内存。当异常处理完毕后，操作系统代码把cpu权限降低，再跳到用户之前执行异常的地方执行代码（相当于操作系统把权限丢给用户程序）
   * 外围设备的中断：I/O设备的读写申请等
   * 具体的切换操作
      * 从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：
      * [1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。
      * [2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。
      * [3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。
综上：由于中断向量表等发生中断、异常、系统调用的执行程序都是操作系统设置的，只要操作系统把这几个地方处理得当，就可以完全掌控cpu而不怕被其他程序夺权。
* 而一开始操作系统的高权限是cpu开机时获得的，只要操作系统处于硬盘恰当的位置，保证第一个获取到这个权限，就可以保证控制cpu
