---
title: 汇编学习
top: false
cover: false
toc: true
mathjax: true
date: 2020-11-04 23:15:10
password:
summary:
tags:
categories:
---
### 对JOS bootloader的汇编分析

<!--more-->

~~~c

#include <inc/mmu.h>

# Start the CPU: switch to 32-bit protected mode, jump into C.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.

.set PROT_MODE_CSEG, 0x8         # kernel code segment selector   
#此处预设代码段选择符
#段选择符的格式： 13位索引+1位TI表指示标志（代表是不是全局描述符）+2位RPL
#因此 0x8  0000000000001 0 00
.set PROT_MODE_DSEG, 0x10        # kernel data segment selector
#此处预设数据段选择符
#     0x10 0000000000010 0 00

.set CR0_PE_ON,      0x1         # protected mode enable flag

#.set symbol, expression设置symbol为expression。

.globl start  
start:                 #函数的开始，相当于main
  .code16                     # Assemble for 16-bit mode    让汇编器按照16位代码汇编
  cli                         # Disable interrupts
  cld                         # String operations increment
#关闭中断，设置字符串操作是递增方向
#cld的作用是将direct flag标志位清零
#it means that instructions that autoincrement the source index and destination index (like MOVS) will increase both of them

  # Set up the important data segment registers (DS, ES, SS).

  xorw    %ax,%ax             # Segment number zero
  movw    %ax,%ds             # -> Data Segment
  movw    %ax,%es             # -> Extra Segment
  movw    %ax,%ss             # -> Stack Segment

  # Enable A20:
  #   For backwards compatibility with the earliest PCs, physical
  #   address line 20 is tied low, so that addresses higher than
  #   1MB wrap around to zero by default.  This code undoes this.

  #激活A20地址位,由于需要兼容早期pc，物理地址的第20位绑定为0，所以高于1MB的地址又回到了0x00000
  #激活A20后，就可以访问所有4G内存，就可以使用保护模式
  #怎么激活呢，由于历史原因A20地址位由键盘控制器芯片8042管理。所以要给8042发命令激活A20
  #8042有两个IO端口：0x60和0x64， 激活流程位： 发送0xd1命令到0x64端口 --> 发送0xdf到0x60
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  #汇编语言有专门的读取端口信息的指令，in out后面的b代表一个字节
  testb   $0x2,%al
  #测试（两操作数作与运算,仅修改标志位，不回送结果）。
  jnz     seta20.1
#发送命令之前，要等待键盘输入缓冲区为空，这通过8042的状态寄存器的第2bit来观察，而状态寄存器的值可以读0x64端口得到。
#上面的指令的意思就是，如果状态寄存器的第2位为1，就跳到seta20.1符号处执行，知道第2位为0，代表缓冲区为空

  movb    $0xd1,%al               # 0xd1 -> port 0x64
  outb    %al,$0x64
#发送0xd1到0x64端口
seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -> port 0x60
  outb    %al,$0x60

  # Switch from real to protected mode, using a bootstrap GDT
  # and segment translation that makes virtual addresses 
  # identical to their physical addresses, so that the 
  # effective memory map does not change during the switch.
  #转入保护模式，这里需要指定一个临时的GDT，来翻译逻辑地址。
  #这里使用的GDT通过gdtdesc段定义，它翻译得到的物理地址和虚拟地址相同（段描述符里的段基址为0）
  #所以转换过程中内存映射不会改变
  lgdt    gdtdesc   
  #lgdt指令把gdtdesc的地址加载进gdtr寄存器，代表全局段描述符表
  movl    %cr0, %eax
  orl     $CR0_PE_ON, %eax
  movl    %eax, %cr0
  #开启保护模式
  # Jump to next instruction, but in 32-bit code segment.
  # Switches processor into 32-bit mode.
  #由于进入保护模式，所有地址都应该是：cs:eip
  ljmp    $PROT_MODE_CSEG, $protcseg         #ljmp cs esp
  #Long jump, use 0xfebc for the CS register and 0x12345678 for the EIP register:
  #ljmp $0xfebc, $0x12345678

  .code32                     # Assemble for 32-bit mode
protcseg:
  # Set up the protected-mode data segment registers
  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector
  movw    %ax, %ds                # -> DS: Data Segment
  movw    %ax, %es                # -> ES: Extra Segment
  movw    %ax, %fs                # -> FS
  movw    %ax, %gs                # -> GS
  movw    %ax, %ss                # -> SS: Stack Segment
  
  # Set up the stack pointer and call into C.
  movl    $start, %esp
  call bootmain

  # If bootmain returns (it shouldn't), loop.
spin:
  jmp spin

# Bootstrap GDT
.p2align 2                                # force 4 byte alignment
gdt:
  SEG_NULL				# null seg
  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg
  SEG(STA_W, 0x0, 0xffffffff)	        # data seg

gdtdesc:
  .word   0x17                            # sizeof(gdt) - 1
  .long   gdt                             # address gdt

~~~

https://www.cnblogs.com/maruixin/p/3175894.html  
https://blog.csdn.net/suz_cheney/article/details/24198003?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param  
https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-73/index.html